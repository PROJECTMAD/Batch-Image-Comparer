<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Image Comparer (with Albums & Viewer)</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --bg-color: #ffffff;
            --bg-secondary-color: #f0f0f0;
            --bg-tertiary-color: #f9f9f9;
            --text-color: #333333;
            --text-secondary-color: #555555;
            --border-color: #e0e0e0;
            --border-light-color: #eeeeee;
            --accent-color: #007bff;
            --accent-hover-color: #0056b3;
            --success-color: #28a745;
            --success-hover-color: #218838;
            --error-color: #dc3545;
            --box-shadow-color: rgba(0,0,0,0.1);
            --input-bg-color: #ffffff;
            --input-border-color: #cccccc;
            --button-text-color: #ffffff;
            --tab-inactive-border: transparent;
            --spinner-light-color: #f3f3f3;
            --lightbox-bg: rgba(0,0,0,0.85);
            --lightbox-nav-bg: rgba(50,50,50,0.6);
            --lightbox-nav-hover-bg: rgba(80,80,80,0.8);
            --modal-overlay-bg: rgba(0,0,0,0.7);
            --slider-handle-bg: rgba(255, 255, 255, 0.8);
            --slider-handle-shadow: rgba(0,0,0,0.5);
        }

        body.dark-theme {
            --bg-color: #1e1e1e;
            --bg-secondary-color: #2a2a2a;
            --bg-tertiary-color: #252525;
            --text-color: #e0e0e0;
            --text-secondary-color: #b0b0b0;
            --border-color: #444444;
            --border-light-color: #383838;
            --accent-color: #0088ff;
            --accent-hover-color: #0066cc;
            --success-color: #30c355;
            --success-hover-color: #26a245;
            --error-color: #ff4c5d;
            --box-shadow-color: rgba(0,0,0,0.3);
            --input-bg-color: #333333;
            --input-border-color: #555555;
            /* --button-text-color: #e0e0e0; */
            --tab-inactive-border: transparent;
            --spinner-light-color: #444444;
            --lightbox-bg: rgba(10,10,10,0.9);
            --lightbox-nav-bg: rgba(30,30,30,0.7);
            --lightbox-nav-hover-bg: rgba(50,50,50,0.9);
            --modal-overlay-bg: rgba(0,0,0,0.8);
            --slider-handle-bg: rgba(50, 50, 50, 0.8);
            --slider-handle-shadow: rgba(255,255,255,0.3);
        }

        /* --- GENERAL STYLES --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: var(--bg-secondary-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 16px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            background-color: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px var(--box-shadow-color);
            width: 98%;
            max-width: 1400px;
            transition: background-color 0.3s, filter 0.3s ease, opacity 0.3s ease;
        }
        
        .container.content-locked {
            filter: blur(5px);
            pointer-events: none;
            opacity: 0.6;
        }


        h1, h2 {
            text-align: center;
            color: var(--text-color);
        }
        h2 { margin-top: 30px; margin-bottom: 15px; border-bottom: 1px solid var(--border-light-color); padding-bottom: 10px;}

        #themeToggleButton {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 8px 12px;
            background-color: var(--bg-tertiary-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            z-index: 1000; /* Theme toggle below lightbox */
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        #themeToggleButton:hover {
            background-color: var(--accent-color);
            color: var(--button-text-color);
        }


        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            color: var(--text-secondary-color);
            font-size: 1.1em;
            border-bottom: 3px solid var(--tab-inactive-border);
            margin-bottom: -1px;
            transition: color 0.2s, border-bottom-color 0.2s;
        }
        .tab-button.active {
            border-bottom-color: var(--accent-color);
            font-weight: bold;
            color: var(--accent-color);
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }


        .album-form-container, .album-selection-container {
            background-color: var(--bg-tertiary-color);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .form-group { margin-bottom: 15px; }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }
        .form-group input[type="text"], 
        .form-group input[type="password"],
        .form-group input[type="url"], /* For DB URL */
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--input-border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            background-color: var(--input-bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .form-group textarea { min-height: 100px; resize: vertical; }

        .form-button, .controls button {
            padding: 10px 20px;
            font-size: 1em;
            color: var(--button-text-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .form-button { background-color: var(--success-color); }
        .form-button:hover { background-color: var(--success-hover-color); }
        .controls button { background-color: var(--accent-color); }
        .controls button:hover:not(:disabled) { background-color: var(--accent-hover-color); }
        .controls button:disabled { background-color: var(--text-secondary-color); cursor: not-allowed; opacity: 0.7; }

        .status-message { margin-top: 10px; font-weight: bold; min-height: 1.2em; }
        .status-success { color: var(--success-color); }
        .status-error { color: var(--error-color); }

        #albumList {
            list-style-type: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
        }
        #albumList li {
            padding: 10px;
            border-bottom: 1px solid var(--border-light-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background-color 0.2s;
        }
        #albumList li:last-child { border-bottom: none; }
        #albumList li:hover { background-color: var(--bg-secondary-color); }
        #albumList li input[type="checkbox"] { margin-right: 10px; transform: scale(1.2); accent-color: var(--accent-color); flex-shrink: 0; }
        .album-item-details { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
        .album-item-title { font-weight: bold; color: var(--text-color); }
        
        .album-item-desc {
            font-size: 0.9em;
            color: var(--text-secondary-color);
            margin-top: 3px;
            white-space: normal;
            word-break: break-word;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            max-height: 3.6em;
            transition: max-height 0.3s ease-out, -webkit-line-clamp 0.3s ease-out;
        }

        .album-item-desc.expanded {
            -webkit-line-clamp: unset;
            max-height: 500px;
            white-space: pre-wrap;
            display: block;
        }

        .album-item-count { font-size: 0.8em; color: var(--text-secondary-color); margin-left: auto; padding-left: 10px; flex-shrink: 0;}

        .controls { display: flex; justify-content: center; align-items: center; margin: 20px 0; gap: 15px;}
        #imageIndicator { font-size: 1.1em; font-weight: bold; min-width: 100px; text-align: center; color: var(--text-color);}

        .image-comparison-area {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            border-top: 1px solid var(--border-light-color);
            padding-top: 20px;
            flex-wrap: nowrap;
            overflow-x: auto;
        }
        .image-pane {
            flex: 1 1 30%;
            min-width: 280px;
            max-width: 32%;
            text-align: center;
            background-color: var(--bg-tertiary-color);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            display: none;
            transition: background-color 0.3s, border-color 0.3s;
            position: relative; /* For potential spinner inside */
        }
        .image-pane.active { display: block; }
        .image-pane h3 { margin-top: 0; color: var(--text-color); font-size: 1.1em; word-break: break-word; min-height: 2.4em;}
        .image-pane img {
            max-width: 100%;
            max-height: 350px;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            object-fit: contain;
            background-color: var(--bg-secondary-color); /* Light background for image area */
            display: block;
            margin-left: auto;
            margin-right: auto;
            cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s, opacity 0.3s;
        }
        .image-pane .filename { margin-top: 8px; font-size: 0.85em; color: var(--text-secondary-color); word-break: break-all; min-height: 2.5em;}
        .error-placeholder { /* Also used as loading placeholder text */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 100px; /* Ensure it takes up space */
            height: 350px; /* Match max-height of img */
            max-height: 350px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-secondary-color);
            color: var(--text-secondary-color);
            font-size: 0.9em;
            box-sizing: border-box;
            padding: 10px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .loading-spinner {
            border: 4px solid var(--spinner-light-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto; /* Default margin */
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- LIGHTBOX STYLES --- */
        .lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--lightbox-bg);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 1001; 
            padding: 20px; 
            box-sizing: border-box;
        }
        .lightbox-overlay.active { display: flex; }

        .lightbox-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .lightbox-image-container {
            width: 100%;
            height: calc(100% - 80px); /* Space for controls */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; 
            position: relative; /* For lightbox spinner positioning and slider view */
        }

        .lightbox-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: transform 0.2s ease-out, opacity 0.3s ease-out;
            transform-origin: center center;
            cursor: grab;
        }
        .lightbox-image.grabbing { cursor: grabbing; }

        .lightbox-image-spinner { /* Spinner specifically for lightbox image */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1; /* Above image while loading */
        }

        .lightbox-close, .lightbox-nav {
            position: absolute;
            background-color: var(--lightbox-nav-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            user-select: none;
            z-index: 10; 
        }
        .lightbox-close:hover, .lightbox-nav:hover { background-color: var(--lightbox-nav-hover-bg); }

        .lightbox-close { top: 15px; right: 15px; }
        .lightbox-prev { left: 15px; top: 50%; transform: translateY(-50%); }
        .lightbox-next { right: 15px; top: 50%; transform: translateY(-50%); }

        .lightbox-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--lightbox-nav-bg);
            padding: 8px 12px;
            border-radius: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 10;
        }
        .lightbox-controls button {
            background: none;
            border: none;
            color: var(--button-text-color);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }
        .lightbox-controls button:hover:not(:disabled) { opacity: 0.8; }
        .lightbox-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
        .lightbox-zoom-level { color: var(--button-text-color); font-size: 0.9em; }

        .lightbox-caption {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--button-text-color);
            background-color: var(--lightbox-nav-bg);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9em;
            text-align: center;
            max-width: 70%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 10;
        }
        .image-title {
            color: var(--accent-color);
            font-weight: bold;
        }
        .lightbox-key-legend {
            position: absolute;
            top: 15px; 
            left: 15px;
            background-color: var(--lightbox-nav-bg);
            color: var(--button-text-color);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em; 
            z-index: 10; 
            max-width: 220px; 
            opacity: 0.85; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            user-select: none;
        }
        .lightbox-key-legend h4 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em; 
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding-bottom: 5px;
            font-weight: 600;
        }
        .lightbox-key-legend ul { list-style: none; padding: 0; margin: 0; }
        .lightbox-key-legend li { margin-bottom: 4px; display: flex; align-items: center; }
        .lightbox-key-legend li:last-child { margin-bottom: 0; }
        .lightbox-key-legend kbd {
            display: inline-block;
            background-color: rgba(0,0,0,0.4); 
            color: var(--button-text-color); 
            padding: 2px 7px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; 
            font-size: 0.95em; 
            margin-right: 10px; 
            text-align: center;
            min-width: 15px; 
        }
        /* --- LIGHTBOX SLIDER STYLES --- */
        #lightboxSliderView {
            /* display: none; set by JS */
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex; /* Will be set to flex by JS when active */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Important */
        }
        #lightboxSliderContent {
            position: relative;
            /* width and height set by JS */
            box-shadow: 0 0 10px rgba(0,0,0,0.5); /* Optional: to delineate the image area */
            user-select: none;
        }
        .slider-comparison-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Relative to lightboxSliderContent */
            height: 100%; /* Relative to lightboxSliderContent */
            object-fit: contain; /* Should be already contained by parent, but good fallback */
            pointer-events: none; /* So they don't interfere with handle dragging */
            /* Clip-path will be applied by JS */
        }
        .slider-handle {
            position: absolute;
            background-color: var(--slider-handle-bg);
            box-shadow: 0 0 3px var(--slider-handle-shadow);
            z-index: 15; /* Above slider images */
            touch-action: none; /* For touch devices */
        }
        .slider-handle.vertical {
            width: 6px;
            height: 100%;
            cursor: ew-resize;
            transform: translateX(-50%); /* Center the handle line */
        }
        .slider-handle.horizontal {
            width: 100%;
            height: 6px;
            cursor: ns-resize;
            transform: translateY(-50%); /* Center the handle line */
        }
        .slider-handle::before { /* Grip indicator */
            content: "";
            position: absolute;
            background-color: var(--text-color);
            opacity: 0.5;
        }
        .slider-handle.vertical::before {
            width: 2px; height: 30px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
         .slider-handle.horizontal::before {
            width: 30px; height: 2px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }


        /* --- API KEY MODAL STYLES --- */
        .api-key-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .api-key-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .api-key-modal-content {
            background-color: var(--bg-color);
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 5px 20px var(--box-shadow-color);
            text-align: center;
            width: 90%;
            max-width: 500px; /* Slightly wider for two inputs */
            color: var(--text-color);
        }
        .api-key-modal-content h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        .api-key-modal-content p {
            margin-bottom: 20px;
            font-size: 0.95em;
            color: var(--text-secondary-color);
        }
        .api-key-modal-content .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        .api-key-modal-content .form-button {
            width: 100%;
            padding: 12px 20px;
            margin-top: 10px;
            background-color: var(--accent-color);
        }
        .api-key-modal-content .form-button:hover {
            background-color: var(--accent-hover-color);
        }
        .api-key-modal-content .status-message {
            margin-top: 15px;
            min-height: 1.2em;
        }
    </style>
</head>
<body>
    <button id="themeToggleButton" title="Toggle Theme">üåì</button>

    <!-- API Key Modal -->
    <div id="apiKeyModalOverlay" class="api-key-modal-overlay">
        <div class="api-key-modal-content">
            <h2>Setup API Access</h2>
            <p>Provide your REST Database endpoint URL and API Key.</p>
            <div class="form-group">
                <label for="dbUrlInput">Database URL (Albums Endpoint):</label>
                <input type="url" id="dbUrlInput" placeholder="e.g., https://your-db.restdb.io/rest/albums">
            </div>
            <div class="form-group">
                <label for="apiKeyInput">API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your API key">
            </div>
            <button id="submitApiKeyBtn" class="form-button">Unlock Application</button>
            <div id="apiKeyStatusMsg" class="status-message"></div>
            <div id="apiKeyLoadingSpinner" class="loading-spinner" style="display:none;"></div>
        </div>
    </div>

    <!-- Main Application Container -->
    <div class="container content-locked">
        <h1>Batch Image Comparer <v1 class="0"></v1></h1>

        <div class="tab-navigation">
            <button class="tab-button active" data-tab="compareTab">Compare Albums</button>
            <button class="tab-button" data-tab="manageTab">Manage Albums</button>
        </div>

        <div id="compareTab" class="tab-content active">
             <h2>Select Albums for Comparison (Up to 3)</h2>
            <div class="album-selection-container">
                <div id="albumListContainer">
                    <p id="albumListLoadingMsg">Loading albums...</p>
                    <div id="albumListLoadingSpinner" class="loading-spinner" style="display:none;"></div>
                    <ul id="albumList"></ul>
                </div>
                <button id="loadSelectedAlbumsBtn" class="form-button" style="margin-top:15px; background-color: var(--accent-color);">Load Selected for Comparison</button>
                <p id="selectionInfo" class="status-message"></p>
            </div>
            <div class="controls">
                <button id="prevBtn" disabled>¬´ Previous</button>
                <span id="imageIndicator">0 / 0</span>
                <button id="nextBtn" disabled>Next ¬ª</button>
                <button id="mainShareBtn" class="form-button" style="margin-left: 15px; background-color: var(--success-color);" title="Share Current Album View" disabled>üîó Share View</button> <!-- ADDED -->
            </div>
            <div class="image-comparison-area">
                <div id="imagePane1" class="image-pane">
                    <h3 id="albumTitle1">Album 1</h3>
                    <div id="img1Placeholder" class="error-placeholder">Select an album</div>
                    <img id="img1" src="#" alt="Image from Album 1" style="display:none;">
                    <p id="img1Name" class="filename">-</p>
                </div>
                <div id="imagePane2" class="image-pane">
                    <h3 id="albumTitle2">Album 2</h3>
                    <div id="img2Placeholder" class="error-placeholder">Select an album</div>
                    <img id="img2" src="#" alt="Image from Album 2" style="display:none;">
                    <p id="img2Name" class="filename">-</p>
                </div>
                <div id="imagePane3" class="image-pane">
                    <h3 id="albumTitle3">Album 3</h3>
                    <div id="img3Placeholder" class="error-placeholder">Select an album</div>
                    <img id="img3" src="#" alt="Image from Album 3" style="display:none;">
                    <p id="img3Name" class="filename">-</p>
                </div>
            </div>
        </div>

        <div id="manageTab" class="tab-content">
            <h2>Create New Album</h2>
            <div class="album-form-container">
                <div class="form-group">
                    <label for="albumTitle">Album Title:</label>
                    <input type="text" id="albumTitleInput" required>
                </div>
                <div class="form-group">
                    <label for="albumDescription">Description (Optional):</label>
                    <textarea id="albumDescriptionInput"></textarea>
                </div>
                <div class="form-group">
                    <label for="albumImageUrls">Image URLs (One per line, direct links):</label>
                    <textarea id="albumImageUrlsInput" placeholder="https://i.ibb.co/your-image1.jpg
https://i.imgur.com/your-image2.jpeg
https://example.com/your-image3.png" required></textarea>
                </div>
                <button id="createAlbumBtn" class="form-button">Create Album</button>
                <div id="createAlbumStatus" class="status-message"></div>
                <div id="createAlbumSpinner" class="loading-spinner" style="display:none;"></div>
            </div>
            <h2>Existing Albums</h2>
            <p style="text-align:center; color: var(--text-secondary-color);">(New albums will appear in the "Compare Albums" tab automatically.)</p>
        </div>
    </div>

    <div id="lightboxOverlay" class="lightbox-overlay">
        <div class="lightbox-content">
             <div id="lightboxKeyLegend" class="lightbox-key-legend">
                <h4>Keyboard Shortcuts</h4>
                <ul>
                    <li><kbd>Esc</kbd> Close</li>
                    <li><kbd>‚Üê</kbd> Prev Image (in set)</li>
                    <li><kbd>‚Üí</kbd> Next Image (in set)</li>
                    <li><kbd>Shift</kbd>+<kbd>‚Üê</kbd> Prev Image Set</li> <!-- ADDED -->
                    <li><kbd>Shift</kbd>+<kbd>‚Üí</kbd> Next Image Set</li> <!-- ADDED -->
                    <li><kbd>+</kbd> Zoom In</li>
                    <li><kbd>-</kbd> Zoom Out</li>
                    <li><kbd>0</kbd> Reset View</li>
                    <li><kbd>S</kbd> Toggle Sliders</li>
                    <li><kbd>Wheel</kbd> Zoom</li>
                    <li><kbd>Drag</kbd> Move (Zoomed)</li>
                </ul>
            </div>
            <span id="lightboxCaption" class="lightbox-caption">Image Title</span>
            <button id="lightboxClose" class="lightbox-close" title="Close (Esc)">√ó</button>
            <button id="lightboxPrev" class="lightbox-nav lightbox-prev" title="Previous Image (Left Arrow)">‚ùÆ</button>
            <button id="lightboxNext" class="lightbox-nav lightbox-next" title="Next Image (Right Arrow)">‚ùØ</button>
            
            <div class="lightbox-image-container">
                <img id="lightboxImage" class="lightbox-image" src="#" alt="Lightbox Image" style="opacity:0;">
                <div id="lightboxImageSpinner" class="loading-spinner lightbox-image-spinner" style="display:none;"></div>

                <!-- Slider Comparison Elements -->
                <div id="lightboxSliderView" style="display: none;"> <!-- Managed by JS -->
                    <div id="lightboxSliderContent"> <!-- This will be sized to the 'contained' image -->
                        <img id="sliderImg1" class="slider-comparison-image" src="#">
                        <img id="sliderImg2" class="slider-comparison-image" src="#">
                        <img id="sliderImg3" class="slider-comparison-image" src="#" style="display:none;">
                        <div id="sliderHandle1" class="slider-handle" style="display:none;"></div>
                        <div id="sliderHandle2" class="slider-handle" style="display:none;"></div>
                    </div>
                </div>
            </div>
            <div class="lightbox-controls">
                <button id="lightboxPrevSetBtn" title="Previous Image Set (Shift + Left Arrow)">‚¨ÖÔ∏è Prev Set</button>
                <button id="lightboxZoomOut" title="Zoom Out (-)">‚ûñ</button>
                <span id="lightboxZoomLevel" class="lightbox-zoom-level">100%</span>
                <button id="lightboxZoomIn" title="Zoom In (+)">‚ûï</button>
                <button id="lightboxZoomReset" title="Reset Zoom (0)">üîÑ</button>
                <button id="lightboxSliderToggleBtn" title="Toggle Slider Comparison (S)">üéöÔ∏è</button>
                <button id="lightboxShareBtn" title="Share Current Comparison (copies link)">üîó</button>
                <button id="lightboxNextSetBtn" title="Next Image Set (Shift + Right Arrow)">Next Set ‚û°Ô∏è</button>
            </div>
        </div>
    </div>

    <script>
        let userApiKey = null;
        let userDbUrl = null; // Will be set after validation
        const DEFAULT_DB_URL = 'https://batchimagecomparer-1d67.restdb.io/rest/albums';
        const MAX_SELECTED_ALBUMS = 3;

        const mainContainer = document.querySelector('.container');
        const apiKeyModalOverlay = document.getElementById('apiKeyModalOverlay');
        const dbUrlInput = document.getElementById('dbUrlInput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const submitApiKeyBtn = document.getElementById('submitApiKeyBtn');
        const apiKeyStatusMsg = document.getElementById('apiKeyStatusMsg');
        const apiKeyLoadingSpinner = document.getElementById('apiKeyLoadingSpinner');

        const themeToggleButton = document.getElementById('themeToggleButton');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const albumTitleInput = document.getElementById('albumTitleInput');
        const albumDescriptionInput = document.getElementById('albumDescriptionInput');
        const albumImageUrlsInput = document.getElementById('albumImageUrlsInput');
        const createAlbumBtn = document.getElementById('createAlbumBtn');
        const createAlbumStatus = document.getElementById('createAlbumStatus');
        const createAlbumSpinner = document.getElementById('createAlbumSpinner');
        const albumListUL = document.getElementById('albumList');
        const albumListLoadingMsg = document.getElementById('albumListLoadingMsg');
        const albumListLoadingSpinner = document.getElementById('albumListLoadingSpinner');
        const loadSelectedAlbumsBtn = document.getElementById('loadSelectedAlbumsBtn');
        const selectionInfo = document.getElementById('selectionInfo');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const mainShareBtn = document.getElementById('mainShareBtn'); // ADDED
        const imageIndicator = document.getElementById('imageIndicator');

        const imagePanes = [
            { id: 'imagePane1', el: document.getElementById('imagePane1'), titleEl: document.getElementById('albumTitle1'), imgEl: document.getElementById('img1'), placeholderEl: document.getElementById('img1Placeholder'), nameEl: document.getElementById('img1Name'), urls: [], albumData: null },
            { id: 'imagePane2', el: document.getElementById('imagePane2'), titleEl: document.getElementById('albumTitle2'), imgEl: document.getElementById('img2'), placeholderEl: document.getElementById('img2Placeholder'), nameEl: document.getElementById('img2Name'), urls: [], albumData: null },
            { id: 'imagePane3', el: document.getElementById('imagePane3'), titleEl: document.getElementById('albumTitle3'), imgEl: document.getElementById('img3'), placeholderEl: document.getElementById('img3Placeholder'), nameEl: document.getElementById('img3Name'), urls: [], albumData: null }
        ];

        const lightboxOverlay = document.getElementById('lightboxOverlay');
        const lightboxImage = document.getElementById('lightboxImage');
        const lightboxImageContainer = document.querySelector('.lightbox-image-container');
        const lightboxImageSpinner = document.getElementById('lightboxImageSpinner');
        const lightboxCaption = document.getElementById('lightboxCaption');
        const lightboxCloseBtn = document.getElementById('lightboxClose');
        const lightboxPrevBtn = document.getElementById('lightboxPrev');
        const lightboxNextBtn = document.getElementById('lightboxNext');
        const lightboxZoomInBtn = document.getElementById('lightboxZoomIn');
        const lightboxZoomOutBtn = document.getElementById('lightboxZoomOut');
        const lightboxZoomResetBtn = document.getElementById('lightboxZoomReset');
        const lightboxZoomLevel = document.getElementById('lightboxZoomLevel');
        const lightboxSliderToggleBtn = document.getElementById('lightboxSliderToggleBtn');

        // Lightbox Slider Elements
        const lightboxSliderView = document.getElementById('lightboxSliderView');
        const lightboxSliderContent = document.getElementById('lightboxSliderContent');
        const sliderImg1 = document.getElementById('sliderImg1');
        const sliderImg2 = document.getElementById('sliderImg2');
        const sliderImg3 = document.getElementById('sliderImg3');
        const sliderHandle1 = document.getElementById('sliderHandle1');
        const sliderHandle2 = document.getElementById('sliderHandle2');
        const lightboxShareBtn = document.getElementById('lightboxShareBtn');
        const lightboxPrevSetBtn = document.getElementById('lightboxPrevSetBtn'); // ADDED
        const lightboxNextSetBtn = document.getElementById('lightboxNextSetBtn'); // ADDED

        let allAlbums = [];
        let selectedAlbumIds = [];
        let currentPairIndex = 0;
        let totalComparablePairs = 0;

        let lightboxCurrentScale = 1;
        const ZOOM_STEP = 0.2;
        const MAX_ZOOM = 5;
        const MIN_ZOOM = 0.2;
        let lightboxActivePanesForView = []; // Panes used for current lightbox view (single or slider)
        let lightboxCurrentImagePaneIndex = 0; // Index within lightboxActivePanesForView for single view
        let lightboxDragStartX, lightboxDragStartY;
        let lightboxIsDragging = false;
        let lightboxImgInitialX = 0; 
        let lightboxImgInitialY = 0;

        let lastKnownMouseX = 0;
        let lastKnownMouseY = 0;
        let animationFrameRequested = false;

        // Slider State
        let isSliderModeActive = false;
        let sliderNumImages = 0;
        let sliderOrientation = 'vertical'; // 'vertical' (sliders move L/R) or 'horizontal' (sliders move U/D)
        let sliderRenderedWidth = 0;
        let sliderRenderedHeight = 0;
        let slider1Percent = 50; // Position as percentage
        let slider2Percent = 66.67; // Position as percentage
        let activeSliderHandle = null;
        let sliderDragStartPos = 0;
        let sharedAlbumIdsToLoad = null;
        let sharedIndexToLoad = null;
        let isProcessingSharedLink = false;
        let sharedInitialSliderMode = false; // ADDED: To store slider mode preference from URL
        let sharedViewContext = 'main';     // ADDED: To store if lightbox should auto-open ('lightbox' or 'main')


        // --- API Key Modal Logic ---
        function showApiKeyModal() {
            mainContainer.classList.add('content-locked');
            apiKeyModalOverlay.classList.add('active');
            dbUrlInput.value = localStorage.getItem('userProvidedDbUrl') || DEFAULT_DB_URL; // Pre-fill DB URL
            apiKeyInput.focus();
        }

        function hideApiKeyModal() {
            apiKeyModalOverlay.classList.remove('active');
            mainContainer.classList.remove('content-locked');
        }

        async function validateApiAccess(keyToTest, dbUrlToTest, isFromStorage = false) {
            apiKeyStatusMsg.textContent = '';
            apiKeyStatusMsg.className = 'status-message';
            apiKeyLoadingSpinner.style.display = 'block';
            submitApiKeyBtn.disabled = true;

            const validationEndpoint = '?metafields=count'; // Fetches only the count of records
            const fullValidationUrl = dbUrlToTest.endsWith('/') ? dbUrlToTest.slice(0, -1) + validationEndpoint : dbUrlToTest + validationEndpoint;


            try {
                const response = await fetch(fullValidationUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-apikey': keyToTest,
                        'cache-control': 'no-cache'
                    }
                });

                if (response.ok) {
                    userApiKey = keyToTest;
                    userDbUrl = dbUrlToTest;
                    localStorage.setItem('userProvidedApiKey', keyToTest);
                    localStorage.setItem('userProvidedDbUrl', dbUrlToTest);
                    apiKeyStatusMsg.textContent = 'API access validated successfully!';
                    apiKeyStatusMsg.className = 'status-message status-success';
                    setTimeout(() => {
                        hideApiKeyModal();
                        initializeAppLogic();
                    }, 500);
                } else {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    throw new Error(`Validation failed: ${response.status} - ${errorData.message || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('API Access Validation Error:', error);
                let userMessage = `Invalid API Key or DB URL. ${error.message.includes('NetworkError') || error.message.includes('Failed to fetch') ? 'Network error or CORS issue.' : error.message.replace('Validation failed: ', '')}. Please check both and try again.`;
                if (error.message.includes('SyntaxError')) { // Often from trying to parse non-JSON as JSON, can happen with wrong DB URL.
                    userMessage = `Invalid DB URL format or non-JSON response. Ensure the URL points to a valid REST Database collection endpoint.`;
                }
                apiKeyStatusMsg.textContent = userMessage;
                apiKeyStatusMsg.className = 'status-message status-error';
                if (isFromStorage) {
                    localStorage.removeItem('userProvidedApiKey');
                    localStorage.removeItem('userProvidedDbUrl');
                }
                userApiKey = null;
                userDbUrl = null;
                if (!apiKeyModalOverlay.classList.contains('active')) {
                    showApiKeyModal();
                }
            } finally {
                apiKeyLoadingSpinner.style.display = 'none';
                submitApiKeyBtn.disabled = false;
            }
        }

        submitApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            const dbUrl = dbUrlInput.value.trim() || DEFAULT_DB_URL; // Use default if empty

            if (!dbUrl) { // Should not happen with default, but as a safeguard
                 apiKeyStatusMsg.textContent = 'Please enter a Database URL.';
                 apiKeyStatusMsg.className = 'status-message status-error';
                 return;
            }
             try { // Validate URL format client-side (basic)
                new URL(dbUrl);
            } catch (_) {
                apiKeyStatusMsg.textContent = 'Invalid Database URL format.';
                apiKeyStatusMsg.className = 'status-message status-error';
                return;
            }
            if (key) {
                validateApiAccess(key, dbUrl);
            } else {
                apiKeyStatusMsg.textContent = 'Please enter an API Key.';
                apiKeyStatusMsg.className = 'status-message status-error';
            }
        });

        apiKeyInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitApiKeyBtn.click(); });
        dbUrlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitApiKeyBtn.click(); });


        function checkAndPromptForApiAccess() {
            const storedApiKey = localStorage.getItem('userProvidedApiKey');
            const storedDbUrl = localStorage.getItem('userProvidedDbUrl');
            if (storedApiKey && storedDbUrl) {
                dbUrlInput.value = storedDbUrl; // Ensure it's displayed if modal re-opens
                apiKeyInput.value = storedApiKey; // For user convenience if validation fails
                validateApiAccess(storedApiKey, storedDbUrl, true);
            } else {
                showApiKeyModal();
            }
        }

        // --- Main App Initialization ---
        function initializeAppLogic() {
            const activeTabButton = document.querySelector('.tab-button.active');
            let currentTab = activeTabButton ? activeTabButton.dataset.tab : 'compareTab';

            if (isProcessingSharedLink && currentTab !== 'compareTab') {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                const compareTabBtn = document.querySelector('.tab-button[data-tab="compareTab"]');
                const compareTabContent = document.getElementById('compareTab');
                if (compareTabBtn) compareTabBtn.classList.add('active');
                if (compareTabContent) compareTabContent.classList.add('active');
                currentTab = 'compareTab';
            }
            
            const loadDataAndFinalize = async () => {
                if ((currentTab === 'compareTab' || isProcessingSharedLink) && allAlbums.length === 0 && userApiKey && userDbUrl) {
                    albumListLoadingMsg.style.display = 'block';
                    albumListLoadingMsg.textContent = 'Loading albums for comparison...';
                    albumListLoadingSpinner.style.display = 'block';
                    try {
                        await fetchAlbums();
                    } catch (e) {
                        albumListLoadingMsg.textContent = `Error loading albums: ${e.message}`;
                        albumListLoadingSpinner.style.display = 'none';
                    }
                }

                if (isProcessingSharedLink && sharedAlbumIdsToLoad && sharedIndexToLoad !== null) {
                    if (allAlbums.length > 0) {
                        await loadSharedComparison(sharedAlbumIdsToLoad, sharedIndexToLoad);
                    } else {
                        const statusElement = document.getElementById('sharedLoadStatus');
                        if(statusElement) statusElement.textContent = "Error: Could not load albums. Shared comparison cannot be processed.";
                        console.error("Cannot load shared comparison: allAlbums is empty.");
                        setTimeout(() => statusElement?.remove(), 5000);
                        isProcessingSharedLink = false;
                    }
                } else {
                    updateComparisonDisplay();
                }
            };

            loadDataAndFinalize();
        }


        // --- THEME ---
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
                themeToggleButton.textContent = '‚òÄÔ∏è';
                themeToggleButton.title = 'Switch to Light Theme';
            } else {
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = 'üåì';
                themeToggleButton.title = 'Switch to Dark Theme';
            }
        }

        function toggleTheme() {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        }
        themeToggleButton.addEventListener('click', toggleTheme);

        // --- TABS ---
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                const newActiveTabContent = document.getElementById(button.dataset.tab);
                if (newActiveTabContent) newActiveTabContent.classList.add('active');
                
                // MODIFIED: Always fetch albums when switching to the 'Compare Albums' tab
                // to ensure the list is up-to-date after potential changes in 'Manage Albums'.
                if (button.dataset.tab === 'compareTab' && userApiKey && userDbUrl) {
                    fetchAlbums(); // This will re-fetch and re-render the album list.
                                   // selectedAlbumIds will be cleared as part of renderAlbumList.
                }
            });
        });
        
        // --- API CALLS ---
        async function apiCall(endpoint = '', method = 'GET', body = null) {
            if (!userApiKey || !userDbUrl) {
                console.error('API call attempted without valid API key or DB URL.');
                showApiKeyModal(); 
                throw new Error('API Key or DB URL not available. Please provide valid credentials.');
            }
            // Ensure userDbUrl doesn't have trailing slash if endpoint also starts with one or is empty
            const base = userDbUrl.endsWith('/') ? userDbUrl.slice(0, -1) : userDbUrl;
            const fullUrl = endpoint ? (base + (endpoint.startsWith('/') ? endpoint : '/' + endpoint)) : base;

            const options = {
                method: method,
                headers: { 'Content-Type': 'application/json', 'x-apikey': userApiKey, 'cache-control': 'no-cache' }
            };
            if (body) options.body = JSON.stringify(body);
            try {
                const response = await fetch(fullUrl, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    if (response.status === 401 || response.status === 404) { // 404 could mean wrong DB URL
                        let msg = `API Key/DB URL seems invalid or has insufficient permissions. (${errorData.message})`;
                        if (response.status === 404) msg = `Database URL endpoint not found. Please check the URL. (${errorData.message})`;
                        
                        apiKeyStatusMsg.textContent = msg;
                        apiKeyStatusMsg.className = 'status-message status-error';
                        localStorage.removeItem('userProvidedApiKey');
                        localStorage.removeItem('userProvidedDbUrl');
                        userApiKey = null;
                        userDbUrl = null;
                        showApiKeyModal();
                    }
                    throw new Error(`API Error: ${response.status} - ${errorData.message || 'Unknown error'}`);
                }
                return await response.json();
            } catch (error) { 
                console.error('API Call Failed:', error); 
                if (!error.message.includes('API Key or DB URL not available')) { 
                    // Further generic error display if needed, but 401/404 above handles credential issues
                }
                throw error; 
            }
        }

        // --- ALBUM MANAGEMENT ---
        async function fetchAlbums() {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; } 
            albumListLoadingMsg.style.display = 'block';
            albumListLoadingMsg.textContent = 'Loading albums...';
            albumListLoadingSpinner.style.display = 'block';
            albumListUL.innerHTML = '';
            try {
                allAlbums = await apiCall(''); // Endpoint is empty for base DB URL
                renderAlbumList();
                albumListLoadingMsg.style.display = 'none';
            } catch (error) {
                albumListLoadingMsg.textContent = `Error loading albums: ${error.message}`;
                albumListLoadingMsg.style.color = 'var(--error-color)';
            } finally { albumListLoadingSpinner.style.display = 'none'; }
        }

        async function createAlbum(albumData) {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; } 
            createAlbumStatus.textContent = '';
            createAlbumSpinner.style.display = 'block';
            try {
                const newAlbum = await apiCall('', 'POST', albumData); // Endpoint is empty
                createAlbumStatus.textContent = `Album "${newAlbum.title}" created successfully!`;
                createAlbumStatus.className = 'status-message status-success';
                albumTitleInput.value = ''; albumDescriptionInput.value = ''; albumImageUrlsInput.value = '';
            } catch (error) {
                createAlbumStatus.textContent = `Error creating album: ${error.message}`;
                createAlbumStatus.className = 'status-message status-error';
            } finally { createAlbumSpinner.style.display = 'none'; }
        }

        createAlbumBtn.addEventListener('click', () => {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; }
            const title = albumTitleInput.value.trim();
            const description = albumDescriptionInput.value.trim();
            const urlsText = albumImageUrlsInput.value.trim();
            if (!title || !urlsText) {
                createAlbumStatus.textContent = 'Title and Image URLs are required.';
                createAlbumStatus.className = 'status-message status-error'; return;
            }
            const imageUrls = urlsText.split('\n').map(url => url.trim()).filter(url => url.length > 0 && (url.startsWith('http://') || url.startsWith('https://')));
            if (imageUrls.length === 0) {
                createAlbumStatus.textContent = 'Please provide at least one valid image URL.';
                createAlbumStatus.className = 'status-message status-error'; return;
            }
            createAlbum({ title, description, imageUrls });
        });

        function renderAlbumList() {
            albumListUL.innerHTML = '';
            if (allAlbums.length === 0) {
                albumListUL.innerHTML = '<li>No albums found. Create one in the "Manage Albums" tab.</li>'; return;
            }
            allAlbums.sort((a,b) => a.title.localeCompare(b.title)).forEach(album => {
                const li = document.createElement('li');
                li.dataset.albumId = album._id;
                li.setAttribute('role', 'option');
                li.setAttribute('aria-selected', selectedAlbumIds.includes(album._id) ? 'true' : 'false');

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = selectedAlbumIds.includes(album._id);
                checkbox.setAttribute('tabindex', '-1');

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'album-item-details';
                
                const titleSpan = document.createElement('span');
                titleSpan.className = 'album-item-title';
                titleSpan.textContent = album.title;
                
                const descSpan = document.createElement('span');
                descSpan.className = 'album-item-desc';
                const fullDesc = album.description ? album.description : 'No description';
                descSpan.dataset.fullDescription = fullDesc; 
                descSpan.textContent = fullDesc; 

                const countSpan = document.createElement('span');
                countSpan.className = 'album-item-count';
                countSpan.textContent = `(${album.imageUrls ? album.imageUrls.length : 0} images)`;

                detailsDiv.appendChild(titleSpan);
                detailsDiv.appendChild(descSpan);
                li.appendChild(checkbox);
                li.appendChild(detailsDiv);
                li.appendChild(countSpan);
                albumListUL.appendChild(li);

                li.addEventListener('click', (event) => {
                    if (event.target.tagName === 'INPUT' && event.target.type === 'checkbox') {
                    } else {
                        checkbox.checked = !checkbox.checked; 
                    }
                    li.setAttribute('aria-selected', checkbox.checked ? 'true' : 'false');
                    handleAlbumSelection(album._id, checkbox.checked);
                    
                    if (!(event.target.tagName === 'INPUT' && event.target.type === 'checkbox')) {
                         descSpan.classList.toggle('expanded');
                    }
                });
            });
        }

        function handleAlbumSelection(albumId, isChecked) {
            const listItem = albumListUL.querySelector(`li[data-album-id="${albumId}"]`);
            if (isChecked) {
                if (selectedAlbumIds.length < MAX_SELECTED_ALBUMS) {
                    if (!selectedAlbumIds.includes(albumId)) selectedAlbumIds.push(albumId);
                    if (listItem) listItem.setAttribute('aria-selected', 'true');
                } else if (!selectedAlbumIds.includes(albumId)) { 
                    const checkbox = listItem ? listItem.querySelector('input[type="checkbox"]') : null;
                    if (checkbox) checkbox.checked = false;
                    if (listItem) listItem.setAttribute('aria-selected', 'false');
                    selectionInfo.textContent = `You can select a maximum of ${MAX_SELECTED_ALBUMS} albums.`;
                    selectionInfo.className = 'status-message status-error';
                    setTimeout(() => { selectionInfo.textContent = ''; }, 3000);
                }
            } else {
                selectedAlbumIds = selectedAlbumIds.filter(id => id !== albumId);
                if (listItem) listItem.setAttribute('aria-selected', 'false');
            }
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const numSelected = selectedAlbumIds.length;
            selectionInfo.textContent = numSelected > 0 ? `${numSelected} album(s) selected.` : '';
            selectionInfo.className = numSelected > 0 ? 'status-message status-success' : 'status-message';
        }

        loadSelectedAlbumsBtn.addEventListener('click', () => {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; }
            imagePanes.forEach(pane => {
                pane.urls = []; pane.albumData = null; pane.el.classList.remove('active');
                clearImagePane(pane, 'Select an album');
            });
            if (selectedAlbumIds.length === 0) {
                selectionInfo.textContent = 'Please select at least one album.';
                selectionInfo.className = 'status-message status-error';
                totalComparablePairs = 0; updateComparisonDisplay(); return;
            }
            selectionInfo.textContent = '';
            let activePaneIndex = 0;
            selectedAlbumIds.forEach(id => {
                const album = allAlbums.find(a => a._id === id);
                if (album && activePaneIndex < MAX_SELECTED_ALBUMS) {
                    const pane = imagePanes[activePaneIndex];
                    pane.urls = album.imageUrls || []; pane.albumData = album;
                    pane.el.classList.add('active'); pane.titleEl.textContent = album.title;
                    activePaneIndex++;
                }
            });
            for (let i = activePaneIndex; i < MAX_SELECTED_ALBUMS; i++) { imagePanes[i].el.classList.remove('active'); }
            prepareComparison();
        });

        // --- IMAGE COMPARISON & DISPLAY ---
        function getFileNameFromUrl(url) {
            if (!url || typeof url !== 'string') return "Invalid URL";
            try { const path = new URL(url).pathname; const parts = path.split('/'); return decodeURIComponent(parts[parts.length - 1]) || url; }
            catch (e) { const parts = url.split('/'); return parts[parts.length - 1] || url; }
        }

        function prepareComparison() {
            const activePanesWithUrls = imagePanes.filter(p => p.albumData && p.urls.length > 0 && p.el.classList.contains('active'));
            totalComparablePairs = activePanesWithUrls.length > 0 ? Math.min(...activePanesWithUrls.map(p => p.urls.length)) : 0;
            currentPairIndex = 0;
            updateComparisonDisplay();
        }

        function clearImagePane(pane, message = "No image loaded") {
            pane.imgEl.src = "#"; pane.imgEl.style.display = 'none'; pane.imgEl.style.opacity = '1'; // Reset opacity
            pane.placeholderEl.textContent = message; pane.placeholderEl.style.display = 'flex';
            pane.nameEl.textContent = "-"; pane.imgEl.onclick = null;
        }

        function setImageForPane(pane, url, paneGlobalIndex) {
            if (!url) { clearImagePane(pane, pane.albumData ? 'No image at this index' : 'No album loaded'); return; }
            
            pane.imgEl.style.display = 'none'; // Hide image initially
            pane.placeholderEl.textContent = 'Loading image...'; // Show loading text
            pane.placeholderEl.style.display = 'flex'; // Ensure placeholder is visible
            // pane.imgEl.style.opacity = '0.5'; // Optional: slightly dim image area if needed

            pane.imgEl.src = url;
            pane.nameEl.textContent = getFileNameFromUrl(url);

            pane.imgEl.onload = () => {
                pane.imgEl.style.display = 'block';
                // pane.imgEl.style.opacity = '1';
                pane.placeholderEl.style.display = 'none'; // Hide placeholder
                pane.imgEl.onclick = () => openLightbox(paneGlobalIndex, currentPairIndex);
            };
            pane.imgEl.onerror = () => {
                pane.imgEl.style.display = 'none';
                // pane.imgEl.style.opacity = '1';
                pane.placeholderEl.textContent = 'Error loading image.';
                pane.placeholderEl.style.display = 'flex'; // Keep placeholder visible with error
                pane.nameEl.textContent = getFileNameFromUrl(url) + " (Error)"; pane.imgEl.onclick = null;
            };
        }

        function updateComparisonDisplay() {
            const activeLoadedPanes = imagePanes.filter(p => p.albumData && p.el.classList.contains('active'));
            const panesWithImagesForCurrentIndex = activeLoadedPanes.filter(p => p.urls && p.urls.length > currentPairIndex);

            let canShareMainView = false; // ADDED

            if (totalComparablePairs > 0 && panesWithImagesForCurrentIndex.length > 0) {
                imageIndicator.textContent = `${currentPairIndex + 1} / ${totalComparablePairs}`;
                prevBtn.disabled = currentPairIndex === 0;
                nextBtn.disabled = currentPairIndex === totalComparablePairs - 1;
                activeLoadedPanes.forEach((pane, index) => {
                     setImageForPane(pane, pane.urls[currentPairIndex], imagePanes.indexOf(pane));
                });
                canShareMainView = true; // ADDED
            } else {
                imageIndicator.textContent = `0 / 0`; prevBtn.disabled = true; nextBtn.disabled = true;
                let singleAlbumNavPossible = false;
                activeLoadedPanes.forEach((pane) => {
                    const paneGlobalIndex = imagePanes.indexOf(pane);
                    if (pane.albumData && pane.urls && pane.urls.length > 0 && activeLoadedPanes.filter(p => p.urls && p.urls.length > 0).length === 1) {
                        setImageForPane(pane, pane.urls[currentPairIndex], paneGlobalIndex);
                        imageIndicator.textContent = `${currentPairIndex + 1} / ${pane.urls.length}`;
                        prevBtn.disabled = currentPairIndex === 0;
                        nextBtn.disabled = currentPairIndex >= pane.urls.length - 1;
                        singleAlbumNavPossible = true;
                        canShareMainView = true; // ADDED
                    } else if (pane.albumData && (!pane.urls || pane.urls.length === 0)) { clearImagePane(pane, 'Album has no images');
                    } else if (pane.albumData) { clearImagePane(pane, 'No image for comparison');
                    } else { clearImagePane(pane, 'No album loaded'); }
                });
                if (!singleAlbumNavPossible) { prevBtn.disabled = true; nextBtn.disabled = true; imageIndicator.textContent = `0 / 0`; }
            }
            updateSliderToggleButton(); // For lightbox slider button
            mainShareBtn.disabled = !canShareMainView; // ADDED: Enable/disable main share button
        }

        // ADDED FUNCTION for main page sharing
        function generateAndCopyMainShareLink() {
            // Use albums that are currently active and loaded in the panes
            const albumIdsToShare = imagePanes
                .filter(p => p.el.classList.contains('active') && p.albumData && p.urls && p.urls.length > currentPairIndex)
                .map(pane => pane.albumData._id);

            if (albumIdsToShare.length === 0) {
                alert("No active albums with images at the current index to share.");
                return;
            }
            
            const shareIndex = currentPairIndex;
            const params = new URLSearchParams();
            params.set('shareAlbums', albumIdsToShare.join(','));
            params.set('shareIndex', shareIndex.toString());

            const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;

            navigator.clipboard.writeText(shareUrl).then(() => {
                const originalText = mainShareBtn.textContent;
                mainShareBtn.textContent = 'Copied!';
                mainShareBtn.disabled = true;
                setTimeout(() => {
                    mainShareBtn.textContent = 'üîó Share View';
                    mainShareBtn.disabled = imageIndicator.textContent === '0 / 0'; // Re-evaluate disable state
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy main share link: ', err);
                prompt("Failed to copy. Please copy this link manually:", shareUrl);
            });
        }

        async function loadSharedComparison(ids, indexToLoad) {
            const statusElement = document.getElementById('sharedLoadStatus');

            if (!allAlbums || allAlbums.length === 0) {
                if (statusElement) statusElement.textContent = "Error: Album list is empty. Cannot process shared link.";
                setTimeout(() => statusElement?.remove(), 5000);
                isProcessingSharedLink = false;
                return;
            }

            // Ensure Compare Tab is active
            const compareTabBtn = document.querySelector('.tab-button[data-tab="compareTab"]');
            const compareTabContent = document.getElementById('compareTab');
            if (!compareTabBtn.classList.contains('active')) {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                compareTabBtn.classList.add('active');
                compareTabContent.classList.add('active');
            }
            
            const validSharedAlbumsData = allAlbums.filter(album => ids.includes(album._id));
            
            if (validSharedAlbumsData.length === 0) {
                if (statusElement) statusElement.textContent = "Error: None of the shared albums could be found in the database.";
                selectionInfo.textContent = "Error: None of the shared albums could be found.";
                selectionInfo.className = 'status-message status-error';
                setTimeout(() => {
                    statusElement?.remove();
                    selectionInfo.textContent = "";
                }, 7000);
                isProcessingSharedLink = false;
                return;
            }
            
            if (validSharedAlbumsData.length < ids.length) {
                if (statusElement) statusElement.textContent = "Warning: Some shared albums were not found. Loading available ones.";
                else { // If status element was removed by a quick API key fix
                    selectionInfo.textContent = "Warning: Some shared albums were not found. Loading available ones.";
                    selectionInfo.className = 'status-message status-error';
                    setTimeout(() => { selectionInfo.textContent = ""; }, 3000);
                }
            }

            selectedAlbumIds = validSharedAlbumsData.map(album => album._id);
            
            renderAlbumList(); // Update checkboxes based on new selectedAlbumIds
            updateSelectionInfo();

            // --- Replicate logic from 'loadSelectedAlbumsBtn' click handler ---
            imagePanes.forEach(pane => {
                pane.urls = []; pane.albumData = null; pane.el.classList.remove('active');
                clearImagePane(pane, 'Select an album');
            });

            let activePaneSetupIndex = 0;
            selectedAlbumIds.forEach(id => {
                const albumData = allAlbums.find(a => a._id === id);
                if (albumData && activePaneSetupIndex < MAX_SELECTED_ALBUMS) {
                    const pane = imagePanes[activePaneSetupIndex];
                    pane.urls = albumData.imageUrls || []; 
                    pane.albumData = albumData;
                    pane.el.classList.add('active'); 
                    pane.titleEl.textContent = albumData.title;
                    activePaneSetupIndex++;
                }
            });
            for (let i = activePaneSetupIndex; i < MAX_SELECTED_ALBUMS; i++) { 
                imagePanes[i].el.classList.remove('active'); 
            }
            
            prepareComparison(); // Calculates totalComparablePairs etc.
            // --- End of replicated logic ---

            // Validate the shared index against the loaded albums
            let maxPossibleIndex = 0;
            const activePanesWithContent = imagePanes.filter(p => p.albumData && p.urls.length > 0 && p.el.classList.contains('active'));

            if (totalComparablePairs > 0) { // Comparison mode with multiple albums
                maxPossibleIndex = totalComparablePairs - 1;
            } else if (activePanesWithContent.length === 1) { // Single album view
                maxPossibleIndex = activePanesWithContent[0].urls.length - 1;
            } else { // No images to show
                maxPossibleIndex = -1; // Indicates no valid index
            }

            if (indexToLoad >= 0 && indexToLoad <= maxPossibleIndex) {
                currentPairIndex = indexToLoad;
                if (statusElement) statusElement.textContent = "Shared comparison loaded successfully!";
            } else {
                if (statusElement) statusElement.textContent = `Warning: Shared image index (${indexToLoad + 1}) is out of bounds. Displaying first available image. Max index: ${maxPossibleIndex + 1}`;
                selectionInfo.textContent = "Warning: Shared image index is out of bounds. Displaying first available image.";
                selectionInfo.className = 'status-message status-error';
                currentPairIndex = 0; // Default to first image
                setTimeout(() => { selectionInfo.textContent = ""; }, 5000);
            }
            
            updateComparisonDisplay(); // Display the images at the (potentially adjusted) currentPairIndex

            if (statusElement) {
                setTimeout(() => statusElement.remove(), statusElement.textContent.startsWith("Error") ? 7000 : 3000);
            }

            if (sharedViewContext === 'lightbox' && validSharedAlbumsData.length > 0 && maxPossibleIndex >=0 && currentPairIndex <= maxPossibleIndex) {
                const firstPaneWithSharedAlbum = imagePanes.find(p => 
                    p.albumData && selectedAlbumIds.includes(p.albumData._id) && p.el.classList.contains('active') && p.urls.length > currentPairIndex
                );
                if (firstPaneWithSharedAlbum) {
                    const paneGlobalIndex = imagePanes.indexOf(firstPaneWithSharedAlbum);
                    setTimeout(() => { 
                        // Pass the sharedInitialSliderMode as an option
                        openLightbox(paneGlobalIndex, currentPairIndex, { initialSliderMode: sharedInitialSliderMode });
                    }, 200);
                }
            }
            // END MODIFIED
            
            isProcessingSharedLink = false; 
            sharedAlbumIdsToLoad = null; 
            sharedIndexToLoad = null;
            sharedInitialSliderMode = false; // ADDED: Reset
            sharedViewContext = 'main';     // ADDED: Reset
        }
        
        prevBtn.addEventListener('click', () => { if (currentPairIndex > 0) { currentPairIndex--; updateComparisonDisplay(); } });
        nextBtn.addEventListener('click', () => {
            let limit = totalComparablePairs;
            const activePanesWithImages = imagePanes.filter(p => p.albumData && p.urls && p.urls.length > 0 && p.el.classList.contains('active'));
            if (activePanesWithImages.length === 1) limit = activePanesWithImages[0].urls.length;
            if (currentPairIndex < limit - 1) { currentPairIndex++; updateComparisonDisplay(); }
        });

        // ADDED HELPER FUNCTION
        function getMaxImageIndex() {
            const activeLoadedPanes = imagePanes.filter(p => p.albumData && p.el.classList.contains('active'));
            // Check for images in *any* of the active loaded panes, not just those at currentPairIndex
            const panesWithAnyImages = activeLoadedPanes.filter(p => p.urls && p.urls.length > 0);

            if (totalComparablePairs > 0) { // Multiple albums in sync for comparison
                return totalComparablePairs -1;
            } else if (panesWithAnyImages.length === 1 && panesWithAnyImages[0].urls) { // Single album loaded with images
                return panesWithAnyImages[0].urls.length -1;
            }
            return -1; // No images to navigate sets for
        }

        // ADDED FUNCTION for lightbox set navigation
        function navigateImageSet(direction) {
            const maxIndex = getMaxImageIndex();
            if (maxIndex === -1) return; // No sets to navigate

            const newIndex = currentPairIndex + direction;

            if (newIndex >= 0 && newIndex <= maxIndex) {
                currentPairIndex = newIndex;
                updateComparisonDisplay(); // Update main page display to reflect new currentPairIndex
                updateLightboxView();    // This will re-render the lightbox (single or slider) for the new set
            }
        }

        // --- LIGHTBOX ---
        function openLightbox(paneGlobalIndex, imageIdxInAlbum, options = {}) {
            lightboxActivePanesForView = imagePanes.filter(p => p.el.classList.contains('active') && p.urls && p.urls.length > imageIdxInAlbum);
            
            if (lightboxActivePanesForView.length === 0) return;

            const startingPane = imagePanes[paneGlobalIndex];
            lightboxCurrentImagePaneIndex = lightboxActivePanesForView.indexOf(startingPane);
            if (lightboxCurrentImagePaneIndex === -1) lightboxCurrentImagePaneIndex = 0; 
            
            lightboxOverlay.classList.add('active');
            document.addEventListener('keydown', handleLightboxKeyPress);
            
            // MODIFIED: Load and apply view mode preference, considering shared link options
            const canUseSlider = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]).length >= 2;

            if (options.initialSliderMode && canUseSlider) { // Preference from shared link
                isSliderModeActive = true;
                localStorage.setItem('lightboxViewMode', 'slider'); // Persist this choice
            } else { // Normal open or shared link without slider preference, or slider not possible
                const preferredMode = localStorage.getItem('lightboxViewMode');
                if (preferredMode === 'slider' && canUseSlider) {
                    isSliderModeActive = true;
                } else {
                    isSliderModeActive = false;
                    // If slider was preferred but not possible, or initialSliderMode was true but not possible,
                    // ensure localStorage reflects 'single' for next manual open.
                    if ((preferredMode === 'slider' && !canUseSlider) || (options.initialSliderMode && !canUseSlider)) {
                         localStorage.setItem('lightboxViewMode', 'single');
                    }
                }
            }
            // END MODIFIED

            updateLightboxView(); 
        }

        function closeLightbox() {
            if (isSliderModeActive) toggleSliderComparisonMode(); // Deactivate sliders if active
            lightboxOverlay.classList.remove('active');
            document.removeEventListener('keydown', handleLightboxKeyPress);
            lightboxImage.src = "#"; // Clear image to stop loading if any
            lightboxImageSpinner.style.display = 'none'; // Hide spinner
            lightboxImage.style.opacity = '0'; // Hide image
        }
        
        function updateLightboxView() {
            if (isSliderModeActive) {
                lightboxImage.style.display = 'none';
                lightboxImageSpinner.style.display = 'none';
                lightboxSliderView.style.display = 'flex';
                setupSliderComparison();
            } else {
                lightboxSliderView.style.display = 'none';
                lightboxImage.style.display = 'block'; // May get hidden by spinner
                resetLightboxZoomAndPosition();
                updateLightboxImage();
            }
            updateLightboxControlsState();
            updateSliderToggleButton();
        }


        function updateLightboxImage() { // For single image view
            if (isSliderModeActive || lightboxActivePanesForView.length === 0 || lightboxCurrentImagePaneIndex < 0 || lightboxCurrentImagePaneIndex >= lightboxActivePanesForView.length) {
                 // If slider mode is active, this function shouldn't be called directly to change image.
                 // Or, if invalid state for single view, try to close or handle.
                if (!isSliderModeActive) closeLightbox();
                return;
            }
            const currentPaneForLightbox = lightboxActivePanesForView[lightboxCurrentImagePaneIndex];
            const imageUrl = currentPaneForLightbox.urls[currentPairIndex]; 
            
            lightboxImage.style.opacity = '0'; // Hide image before loading new one
            lightboxImageSpinner.style.display = 'block'; // Show spinner
            resetLightboxZoomAndPosition(); // Reset zoom/pan for the upcoming image

            lightboxImage.src = imageUrl;
            lightboxCaption.textContent = `${currentPaneForLightbox.albumData.title} - ${getFileNameFromUrl(imageUrl)}`;

            lightboxImage.onload = () => {
                lightboxImageSpinner.style.display = 'none';
                lightboxImage.style.opacity = '1';
            };
            lightboxImage.onerror = () => {
                lightboxImageSpinner.style.display = 'none';
                lightboxImage.style.opacity = '1'; // Show "broken image" icon or alt text
                lightboxCaption.textContent = `Error loading: ${getFileNameFromUrl(imageUrl)}`;
            };
        }
        
        function navigateLightbox(direction) {
            if (isSliderModeActive || lightboxActivePanesForView.length <= 1) return;
            lightboxCurrentImagePaneIndex = (lightboxCurrentImagePaneIndex + direction + lightboxActivePanesForView.length) % lightboxActivePanesForView.length;
            updateLightboxImage();
        }

        function updateLightboxControlsState() {
            const navDisabled = isSliderModeActive || lightboxActivePanesForView.length <= 1;
            const navNone = navDisabled ? "none" : "flex";
            lightboxPrevBtn.disabled = navDisabled;
            lightboxNextBtn.disabled = navDisabled;
            lightboxPrevBtn.style.display = navNone;
            lightboxNextBtn.style.display = navNone;

            const zoomDisabled = isSliderModeActive;
            lightboxZoomInBtn.disabled = zoomDisabled;
            lightboxZoomOutBtn.disabled = zoomDisabled;
            lightboxZoomResetBtn.disabled = zoomDisabled;
            if (zoomDisabled) lightboxZoomLevel.textContent = 'N/A';
            else lightboxZoomLevel.textContent = `${Math.round(lightboxCurrentScale * 100)}%`;
            
            // MODIFIED: Allow share button in slider mode
            const shareDisabled = lightboxActivePanesForView.length === 0 || 
                                  imagePanes.filter(p => p.el.classList.contains('active') && p.albumData).length === 0;
            lightboxShareBtn.disabled = shareDisabled;

            // ADDED: Logic for Set Navigation Buttons
            const maxImageIdx = getMaxImageIndex();
            const setNavPossible = maxImageIdx !== -1;
            lightboxPrevSetBtn.disabled = !setNavPossible || currentPairIndex === 0;
            lightboxNextSetBtn.disabled = !setNavPossible || currentPairIndex === maxImageIdx;
            // END ADDED
        }


        function setLightboxZoom(newScale) {
            if (isSliderModeActive) return;
            lightboxCurrentScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale));
            let unscaledX = 0, unscaledY = 0;
            const currentTransform = lightboxImage.style.transform;
            const translateMatch = currentTransform.match(/translate\(([^p]+)px, ([^p]+)px\)/);
            if (translateMatch) {
                unscaledX = parseFloat(translateMatch[1]);
                unscaledY = parseFloat(translateMatch[2]);
            }
            lightboxImage.style.transform = `translate(${unscaledX}px, ${unscaledY}px) scale(${lightboxCurrentScale})`;
            lightboxZoomLevel.textContent = `${Math.round(lightboxCurrentScale * 100)}%`;
            lightboxImage.style.cursor = lightboxCurrentScale > 1 ? 'grab' : 'default';
        }

        function resetLightboxZoomAndPosition() {
            if (isSliderModeActive) return;
            lightboxCurrentScale = 1;
            lightboxImage.style.transform = 'translate(0px, 0px) scale(1)'; 
            lightboxZoomLevel.textContent = '100%';
            lightboxImage.style.cursor = 'default';
        }

        lightboxCloseBtn.addEventListener('click', closeLightbox);
        lightboxPrevBtn.addEventListener('click', () => navigateLightbox(-1));
        lightboxNextBtn.addEventListener('click', () => navigateLightbox(1));
        lightboxZoomInBtn.addEventListener('click', () => setLightboxZoom(lightboxCurrentScale + ZOOM_STEP));
        lightboxZoomOutBtn.addEventListener('click', () => setLightboxZoom(lightboxCurrentScale - ZOOM_STEP));
        lightboxZoomResetBtn.addEventListener('click', resetLightboxZoomAndPosition);
        lightboxPrevSetBtn.addEventListener('click', () => navigateImageSet(-1)); // ADDED
        lightboxNextSetBtn.addEventListener('click', () => navigateImageSet(1));   // ADDED
        lightboxShareBtn.addEventListener('click', generateAndCopyShareLink);
        mainShareBtn.addEventListener('click', generateAndCopyMainShareLink); // ADDED

        lightboxOverlay.addEventListener('wheel', (e) => {
            if (isSliderModeActive) return;
            handleLightboxWheel(e)
        }, { passive: false });

        function handleLightboxWheel(e) {
            e.preventDefault();
            const zoomFactor = 0.5; 
            const direction = e.deltaY < 0 ? 1 : -1;
            const newScale = lightboxCurrentScale + (direction * ZOOM_STEP * zoomFactor);
            setLightboxZoom(newScale);
        }

        lightboxImage.addEventListener('mousedown', (e) => {
            if (isSliderModeActive || lightboxCurrentScale <= 1 || lightboxImage.style.opacity === '0') return; // Don't drag if invisible/loading
            lightboxIsDragging = true;
            lightboxImage.classList.add('grabbing');
            const computedStyle = window.getComputedStyle(lightboxImage);
            const transformMatrix = new DOMMatrix(computedStyle.transform);
            lightboxImgInitialX = transformMatrix.m41;
            lightboxImgInitialY = transformMatrix.m42;
            lightboxDragStartX = e.clientX;
            lightboxDragStartY = e.clientY;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isSliderModeActive) { handleSliderDragMove(e); return; }
            if (!lightboxIsDragging || lightboxCurrentScale <= 1) return;
            lastKnownMouseX = e.clientX;
            lastKnownMouseY = e.clientY;
            if (!animationFrameRequested) {
                requestAnimationFrame(updateImageTransformForDrag);
                animationFrameRequested = true;
            }
        });

        function updateImageTransformForDrag() {
            animationFrameRequested = false;
            if (!lightboxIsDragging) return;
            const dxScreen = lastKnownMouseX - lightboxDragStartX;
            const dyScreen = lastKnownMouseY - lightboxDragStartY;
            const newX = lightboxImgInitialX + dxScreen; // Dragging is 1:1 with mouse, scale doesn't affect dx/dy for translation part
            const newY = lightboxImgInitialY + dyScreen;
            lightboxImage.style.transform = `translate(${newX}px, ${newY}px) scale(${lightboxCurrentScale})`;
        }


        document.addEventListener('mouseup', (e) => {
            if (isSliderModeActive) { handleSliderDragEnd(e); return; }
            if (lightboxIsDragging) {
                lightboxIsDragging = false;
                lightboxImage.classList.remove('grabbing');
            }
        });
        // For mouse leaving the window while dragging
        document.addEventListener('mouseleave', (e) => {
            if (isSliderModeActive) { if(activeSliderHandle) handleSliderDragEnd(e); return;}
            if (lightboxIsDragging) {
                lightboxIsDragging = false;
                lightboxImage.classList.remove('grabbing');
            }
        });
        
        function handleLightboxKeyPress(e) {
            if (e.key === 'Escape') closeLightbox();
            
            // ADDED: Shift key check for set navigation
            if (e.shiftKey) {
                if (e.key === 'ArrowLeft') {
                    navigateImageSet(-1);
                    return; // Consume event
                }
                if (e.key === 'ArrowRight') {
                    navigateImageSet(1);
                    return; // Consume event
                }
            }
            // END ADDED

            if (isSliderModeActive) {
                if (e.key === 's' || e.key === 'S') toggleSliderComparisonMode();
                // Other keys are disabled in slider mode for now
                return;
            }
            // else, normal lightbox key handling
            if (e.key === 'ArrowLeft') navigateLightbox(-1); // Navigates within a set
            if (e.key === 'ArrowRight') navigateLightbox(1); // Navigates within a set
            if (e.key === '+') setLightboxZoom(lightboxCurrentScale + ZOOM_STEP);
            if (e.key === '-') setLightboxZoom(lightboxCurrentScale - ZOOM_STEP);
            if (e.key === '0') resetLightboxZoomAndPosition();
            if (e.key === 's' || e.key === 'S') toggleSliderComparisonMode();
        }

        function generateAndCopyShareLink() {
            if (lightboxActivePanesForView.length === 0) {
                alert("No active images to share.");
                return;
            }

            const albumIdsToShare = imagePanes
                .filter(p => p.el.classList.contains('active') && p.albumData && p.urls && p.urls.length > currentPairIndex)
                .map(pane => pane.albumData._id);

            if (albumIdsToShare.length === 0) {
                alert("Cannot determine albums to share for the current view.");
                return;
            }
            
            const shareIndex = currentPairIndex;

            const params = new URLSearchParams();
            params.set('shareAlbums', albumIdsToShare.join(','));
            params.set('shareIndex', shareIndex.toString());
            params.set('viewContext', 'lightbox'); // ADDED: Indicate this share is from lightbox

            if (isSliderModeActive) { // ADDED: Respect slider mode
                params.set('sliderMode', 'true');
            }
            // END ADDED

            const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;

            navigator.clipboard.writeText(shareUrl).then(() => {
                const originalText = lightboxShareBtn.innerHTML;
                lightboxShareBtn.innerHTML = 'Copied!';
                lightboxShareBtn.disabled = true;
                setTimeout(() => {
                    lightboxShareBtn.innerHTML = 'üîó'; 
                    updateLightboxControlsState(); 
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy share link: ', err);
                prompt("Failed to copy. Please copy this link manually:", shareUrl);
            });
        }

        // --- LIGHTBOX SLIDER COMPARISON ---
        lightboxSliderToggleBtn.addEventListener('click', toggleSliderComparisonMode);

        function updateSliderToggleButton() {
            const numComparable = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]).length;
            lightboxSliderToggleBtn.disabled = numComparable < 2;
            lightboxSliderToggleBtn.innerHTML = isSliderModeActive ? 'Exit Sliders' : 'üéöÔ∏è';
        }

        function toggleSliderComparisonMode() {
            const sliderImagePanes = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]);
            sliderNumImages = sliderImagePanes.length;

            if (sliderNumImages < 2 && !isSliderModeActive) { // Trying to activate slider without enough images
                console.warn("Slider mode requires at least 2 images.");
                // Ensure button text is correct if it was clicked to activate
                lightboxSliderToggleBtn.innerHTML = 'üéöÔ∏è';
                isSliderModeActive = false; // Explicitly ensure it's false
                localStorage.setItem('lightboxViewMode', 'single'); // Save fallback
                updateLightboxControlsState(); // Update button states
                return; 
            }
            
            isSliderModeActive = !isSliderModeActive;
            
            // ADDED: Save preference
            localStorage.setItem('lightboxViewMode', isSliderModeActive ? 'slider' : 'single');
            // END ADDED

            updateLightboxView(); // This will call setupSliderComparison if isSliderModeActive is true
        }
        
        async function setupSliderComparison() {
            lightboxImageSpinner.style.display = 'block'; // Show spinner while setting up sliders
            
            const sliderImagePanes = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]);
            sliderNumImages = sliderImagePanes.length;

            if (sliderNumImages < 2) {
                console.warn("Cannot setup slider comparison with less than 2 images.");
                toggleSliderComparisonMode(); // Revert
                lightboxImageSpinner.style.display = 'none';
                return;
            }

            // 1. Determine rendered dimensions based on the first image
            const firstImageURL = sliderImagePanes[0].urls[currentPairIndex];
            const tempImg = new Image();
            tempImg.onload = () => {
                const containerWidth = lightboxImageContainer.clientWidth;
                const containerHeight = lightboxImageContainer.clientHeight;
                const imgAspectRatio = tempImg.naturalWidth / tempImg.naturalHeight;
                const containerAspectRatio = containerWidth / containerHeight;

                if (imgAspectRatio > containerAspectRatio) { // Image is wider or less tall than container
                    sliderRenderedWidth = containerWidth;
                    sliderRenderedHeight = containerWidth / imgAspectRatio;
                } else { // Image is taller or less wide
                    sliderRenderedHeight = containerHeight;
                    sliderRenderedWidth = containerHeight * imgAspectRatio;
                }

                lightboxSliderContent.style.width = `${sliderRenderedWidth}px`;
                lightboxSliderContent.style.height = `${sliderRenderedHeight}px`;

                // Determine orientation for sliders
                sliderOrientation = (sliderRenderedWidth > sliderRenderedHeight) ? 'vertical' : 'horizontal';

                // Load images into slider image elements
                sliderImg1.src = firstImageURL;
                sliderImg2.src = sliderImagePanes[1].urls[currentPairIndex];
                sliderImg1.style.display = 'block';
                sliderImg2.style.display = 'block';

                if (sliderNumImages === 3) {
                    sliderImg3.src = sliderImagePanes[2].urls[currentPairIndex];
                    sliderImg3.style.display = 'block';
                } else {
                    sliderImg3.style.display = 'none';
                    sliderImg3.src = "#";
                }
                
                // Wait for all slider images to load before positioning handles (simplification)
                // A more robust way would use Promise.all for image.onload
                Promise.all(
                    [sliderImg1, sliderImg2, sliderNumImages === 3 ? sliderImg3 : null]
                    .filter(Boolean)
                    .map(img => new Promise(resolve => {
                        if (img.complete) resolve(); else img.onload = img.onerror = resolve;
                    }))
                ).then(() => {
                    initializeSliderHandles();
                    updateSliderClipping();
                    lightboxImageSpinner.style.display = 'none';
                });
                
                lightboxCaption.textContent = '';

                // prefix
                lightboxCaption.appendChild(document.createTextNode('Comparing: '));

                sliderImagePanes.forEach((pane, idx) => {
                // create a span just for the title
                const titleSpan = document.createElement('span');
                titleSpan.textContent = pane.albumData.title;
                titleSpan.classList.add('image-title');
                lightboxCaption.appendChild(titleSpan);

                // add the ‚Äú vs ‚Äù separator if not last
                if (idx < sliderImagePanes.length - 1) {
                    lightboxCaption.appendChild(document.createTextNode(' vs '));
                }
                });

            };
            tempImg.onerror = () => {
                console.error("Failed to load first image for slider dimensions.");
                lightboxImageSpinner.style.display = 'none';
                toggleSliderComparisonMode(); // Revert
            };
            tempImg.src = firstImageURL;
        }

        function initializeSliderHandles() {
            sliderHandle1.style.display = 'block';
            sliderHandle1.className = `slider-handle ${sliderOrientation}`;
            
            if (sliderNumImages === 2) {
                slider1Percent = 50;
                sliderHandle2.style.display = 'none';
            } else if (sliderNumImages === 3) {
                slider1Percent = 33.33;
                slider2Percent = 66.67;
                sliderHandle2.style.display = 'block';
                sliderHandle2.className = `slider-handle ${sliderOrientation}`;
            }
            positionSliderHandles();
        }

        function positionSliderHandles() {
            if (sliderOrientation === 'vertical') { // Sliders are vertical lines, move L/R
                const pos1 = sliderRenderedWidth * (slider1Percent / 100);
                sliderHandle1.style.left = `${pos1}px`;
                sliderHandle1.style.top = '0px';
                if (sliderNumImages === 3) {
                    const pos2 = sliderRenderedWidth * (slider2Percent / 100);
                    sliderHandle2.style.left = `${pos2}px`;
                    sliderHandle2.style.top = '0px';
                }
            } else { // Sliders are horizontal lines, move U/D
                const pos1 = sliderRenderedHeight * (slider1Percent / 100);
                sliderHandle1.style.top = `${pos1}px`;
                sliderHandle1.style.left = '0px';
                if (sliderNumImages === 3) {
                    const pos2 = sliderRenderedHeight * (slider2Percent / 100);
                    sliderHandle2.style.top = `${pos2}px`;
                    sliderHandle2.style.left = '0px';
                }
            }
        }

        function updateSliderClipping() {
            const s1p = (sliderOrientation === 'vertical' ? sliderRenderedWidth : sliderRenderedHeight) * (slider1Percent / 100);
            let s2p;
            if (sliderNumImages === 3) {
                s2p = (sliderOrientation === 'vertical' ? sliderRenderedWidth : sliderRenderedHeight) * (slider2Percent / 100);
            }

            if (sliderOrientation === 'vertical') { // Vertical sliders, clip width
                sliderImg1.style.clipPath = `polygon(0 0, ${s1p}px 0, ${s1p}px 100%, 0 100%)`;
                if (sliderNumImages === 2) {
                    sliderImg2.style.clipPath = `polygon(${s1p}px 0, 100% 0, 100% 100%, ${s1p}px 100%)`;
                } else if (sliderNumImages === 3) {
                    sliderImg2.style.clipPath = `polygon(${s1p}px 0, ${s2p}px 0, ${s2p}px 100%, ${s1p}px 100%)`;
                    sliderImg3.style.clipPath = `polygon(${s2p}px 0, 100% 0, 100% 100%, ${s2p}px 100%)`;
                }
            } else { // Horizontal sliders, clip height
                sliderImg1.style.clipPath = `polygon(0 0, 100% 0, 100% ${s1p}px, 0 ${s1p}px)`;
                if (sliderNumImages === 2) {
                    sliderImg2.style.clipPath = `polygon(0 ${s1p}px, 100% ${s1p}px, 100% 100%, 0 100%)`;
                } else if (sliderNumImages === 3) {
                    sliderImg2.style.clipPath = `polygon(0 ${s1p}px, 100% ${s1p}px, 100% ${s2p}px, 0 ${s2p}px)`;
                    sliderImg3.style.clipPath = `polygon(0 ${s2p}px, 100% ${s2p}px, 100% 100%, 0 100%)`;
                }
            }
        }
        
        [sliderHandle1, sliderHandle2].forEach(handle => {
            handle.addEventListener('mousedown', handleSliderDragStart);
            handle.addEventListener('touchstart', handleSliderDragStart, { passive: false });
        });

        function handleSliderDragStart(e) {
            if (!isSliderModeActive) return;
            e.preventDefault(); // Prevent text selection, etc.
            activeSliderHandle = e.currentTarget;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);

            if (sliderOrientation === 'vertical') {
                sliderDragStartPos = clientX - activeSliderHandle.getBoundingClientRect().left;
            } else {
                sliderDragStartPos = clientY - activeSliderHandle.getBoundingClientRect().top;
            }
            // Global listeners for mousemove/mouseup are already set up
            // For touch, we add them here
            document.addEventListener('touchmove', handleSliderDragMove, { passive: false });
            document.addEventListener('touchend', handleSliderDragEnd);
        }

        function handleSliderDragMove(e) {
            if (!isSliderModeActive || !activeSliderHandle) return;
            e.preventDefault();

            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const rect = lightboxSliderContent.getBoundingClientRect();
            let newPercent;

            if (sliderOrientation === 'vertical') {
                let newX = clientX - rect.left - (activeSliderHandle === sliderHandle1 ? sliderHandle1.offsetWidth / 2 : sliderHandle2.offsetWidth / 2);
                newX = Math.max(0, Math.min(newX, sliderRenderedWidth));
                newPercent = (newX / sliderRenderedWidth) * 100;

                if (activeSliderHandle === sliderHandle1) {
                    if (sliderNumImages === 3) newPercent = Math.min(newPercent, slider2Percent - 1); // Ensure min 1% gap
                    slider1Percent = Math.max(0, Math.min(100, newPercent));
                } else { // sliderHandle2
                    newPercent = Math.max(newPercent, slider1Percent + 1); // Ensure min 1% gap
                    slider2Percent = Math.max(0, Math.min(100, newPercent));
                }
            } else { // horizontal
                let newY = clientY - rect.top - (activeSliderHandle === sliderHandle1 ? sliderHandle1.offsetHeight / 2 : sliderHandle2.offsetHeight / 2);
                newY = Math.max(0, Math.min(newY, sliderRenderedHeight));
                newPercent = (newY / sliderRenderedHeight) * 100;

                if (activeSliderHandle === sliderHandle1) {
                    if (sliderNumImages === 3) newPercent = Math.min(newPercent, slider2Percent - 1);
                    slider1Percent = Math.max(0, Math.min(100, newPercent));
                } else { // sliderHandle2
                    newPercent = Math.max(newPercent, slider1Percent + 1);
                    slider2Percent = Math.max(0, Math.min(100, newPercent));
                }
            }
            positionSliderHandles();
            updateSliderClipping();
        }

        function handleSliderDragEnd(e) {
            if (!isSliderModeActive || !activeSliderHandle) return;
            activeSliderHandle = null;
            document.removeEventListener('touchmove', handleSliderDragMove);
            document.removeEventListener('touchend', handleSliderDragEnd);
        }


        // --- PAGE LOAD ---
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);

            const urlParams = new URLSearchParams(window.location.search);
            const albumsParam = urlParams.get('shareAlbums');
            const indexParam = urlParams.get('shareIndex');
            const sliderModeParam = urlParams.get('sliderMode'); // ADDED
            const viewContextParam = urlParams.get('viewContext'); // ADDED

            if (albumsParam && indexParam) {
                sharedAlbumIdsToLoad = albumsParam.split(',').filter(id => id.trim() !== '');
                sharedIndexToLoad = parseInt(indexParam, 10);
                sharedInitialSliderMode = sliderModeParam === 'true'; // ADDED: Store boolean
                sharedViewContext = viewContextParam || 'main';      // ADDED: Default to 'main' if not present
                
                if (sharedAlbumIdsToLoad.length > 0 && !isNaN(sharedIndexToLoad)) {
                    isProcessingSharedLink = true;

                    const newUrl = window.location.origin + window.location.pathname;
                    history.replaceState(null, '', newUrl);
                    
                    const tempStatus = document.createElement('p');
                    tempStatus.id = 'sharedLoadStatus';
                    tempStatus.textContent = 'Attempting to load shared comparison... Please wait for API validation and album loading.';
                    tempStatus.style.textAlign = 'center';
                    // ... (rest of tempStatus styling)
                    document.body.insertBefore(tempStatus, mainContainer); 
                } else {
                    sharedAlbumIdsToLoad = null;
                    sharedIndexToLoad = null;
                    sharedInitialSliderMode = false; // Reset if params are invalid
                    sharedViewContext = 'main';      // Reset
                }
            }

            checkAndPromptForApiAccess();
        });
    </script>
</body>
</html>