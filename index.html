<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="app-version" content="1.2">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Image Comparer (with Albums & Viewer)</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --bg-color: #ffffff;
            --bg-secondary-color: #f0f0f0;
            --bg-tertiary-color: #f9f9f9;
            --text-color: #333333;
            --text-secondary-color: #555555;
            --border-color: #e0e0e0;
            --border-light-color: #eeeeee;
            --accent-color: #007bff;
            --accent-hover-color: #0056b3;
            --success-color: #28a745;
            --success-hover-color: #218838;
            --error-color: #dc3545;
            --box-shadow-color: rgba(0,0,0,0.1);
            --input-bg-color: #ffffff;
            --input-border-color: #cccccc;
            --button-text-color: #ffffff;
            --tab-inactive-border: transparent;
            --spinner-light-color: #f3f3f3;
            --lightbox-bg: rgba(0,0,0,0.85);
            --lightbox-nav-bg: rgba(50,50,50,0.6);
            --lightbox-nav-hover-bg: rgba(80,80,80,0.8);
            --modal-overlay-bg: rgba(0,0,0,0.7);
            --slider-handle-bg: rgba(255, 255, 255, 0.8);
            --slider-handle-shadow: rgba(0,0,0,0.5);
        }

        body.dark-theme {
            --bg-color: #1e1e1e;
            --bg-secondary-color: #2a2a2a;
            --bg-tertiary-color: #252525;
            --text-color: #e0e0e0;
            --text-secondary-color: #b0b0b0;
            --border-color: #444444;
            --border-light-color: #383838;
            --accent-color: #0088ff;
            --accent-hover-color: #0066cc;
            --success-color: #30c355;
            --success-hover-color: #26a245;
            --error-color: #ff4c5d;
            --box-shadow-color: rgba(0,0,0,0.3);
            --input-bg-color: #333333;
            --input-border-color: #555555;
            /* --button-text-color: #e0e0e0; */
            --tab-inactive-border: transparent;
            --spinner-light-color: #444444;
            --lightbox-bg: rgba(10,10,10,0.9);
            --lightbox-nav-bg: rgba(30,30,30,0.7);
            --lightbox-nav-hover-bg: rgba(50,50,50,0.9);
            --modal-overlay-bg: rgba(0,0,0,0.8);
            --slider-handle-bg: rgba(50, 50, 50, 0.8);
            --slider-handle-shadow: rgba(255,255,255,0.3);
        }

        /* --- GENERAL STYLES --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: var(--bg-secondary-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 16px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            background-color: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px var(--box-shadow-color);
            width: 98%;
            max-width: 1400px;
            transition: background-color 0.3s, filter 0.3s ease, opacity 0.3s ease;
        }
        
        .container.content-locked {
            filter: blur(5px);
            pointer-events: none;
            opacity: 0.6;
        }


        h1, h2 {
            text-align: center;
            color: var(--text-color);
        }
        h2 { margin-top: 30px; margin-bottom: 15px; border-bottom: 1px solid var(--border-light-color); padding-bottom: 10px;}

        #themeToggleButton {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 8px 12px;
            background-color: var(--bg-tertiary-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            z-index: 1000; /* Theme toggle below lightbox */
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        #themeToggleButton:hover {
            background-color: var(--accent-color);
            color: var(--button-text-color);
        }


        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            color: var(--text-secondary-color);
            font-size: 1.1em;
            border-bottom: 3px solid var(--tab-inactive-border);
            margin-bottom: -1px;
            transition: color 0.2s, border-bottom-color 0.2s;
        }
        .tab-button.active {
            border-bottom-color: var(--accent-color);
            font-weight: bold;
            color: var(--accent-color);
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }


        .album-form-container, .album-selection-container {
            background-color: var(--bg-tertiary-color);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
            display: contents;
        }
        .form-group { margin-bottom: 15px; }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }
        .form-group input[type="text"], 
        .form-group input[type="password"],
        .form-group input[type="url"], /* For DB URL */
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--input-border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            background-color: var(--input-bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .form-group textarea { min-height: 100px; resize: vertical; }

        .form-button, .controls button {
            padding: 10px 20px;
            font-size: 1em;
            color: var(--button-text-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .form-button { background-color: var(--success-color); }
        .form-button:hover { background-color: var(--success-hover-color); }
        .controls button { background-color: var(--accent-color); }
        .controls button:hover:not(:disabled) { background-color: var(--accent-hover-color); }
        .controls button:disabled { background-color: var(--text-secondary-color); cursor: not-allowed; opacity: 0.7; }

        .status-message { margin-top: 10px; font-weight: bold; min-height: 1.2em; }
        .status-success { color: var(--success-color); }
        .status-error { color: var(--error-color); }

        #albumList {
            list-style-type: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
        }
        #albumList li {
            padding: 10px;
            border-bottom: 1px solid var(--border-light-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background-color 0.2s;
        }
        #albumList li:last-child { border-bottom: none; }
        #albumList li:hover { background-color: var(--bg-secondary-color); }
        #albumList li input[type="checkbox"] { margin-right: 10px; transform: scale(1.2); accent-color: var(--accent-color); flex-shrink: 0; }
        .album-item-details { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
        .album-item-title { font-weight: bold; color: var(--text-color); }
        
        .album-item-desc {
            font-size: 0.9em;
            color: var(--text-secondary-color);
            margin-top: 3px;
            white-space: normal;
            word-break: break-word;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            max-height: 3.6em;
            transition: max-height 0.3s ease-out, -webkit-line-clamp 0.3s ease-out;
        }

        .album-item-desc.expanded {
            -webkit-line-clamp: unset;
            line-clamp: unset;
            max-height: 500px;
            white-space: pre-wrap;
            display: block;
        }

        .album-item-count { font-size: 0.8em; color: var(--text-secondary-color); margin-left: auto; padding-left: 10px; flex-shrink: 0;}

        .controls { display: flex; justify-content: center; align-items: center; margin: 20px 0; gap: 15px;}
        #imageIndicator { font-size: 1.1em; font-weight: bold; min-width: 100px; text-align: center; color: var(--text-color);}

        .image-comparison-area {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            border-top: 1px solid var(--border-light-color);
            padding-top: 20px;
            flex-wrap: nowrap;
            overflow-x: auto;
        }
        .image-pane {
            flex: 1 1 30%;
            min-width: 280px;
            max-width: 32%;
            text-align: center;
            background-color: var(--bg-tertiary-color);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            display: none;
            transition: background-color 0.3s, border-color 0.3s;
            position: relative; /* For potential spinner inside */
        }
        .image-pane.active { display: block; }
        .image-pane h3 { margin-top: 0; color: var(--text-color); font-size: 1.1em; word-break: break-word; min-height: 2.4em;}
        .image-pane img {
            max-width: 100%;
            max-height: 350px;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            object-fit: contain;
            background-color: var(--bg-secondary-color); /* Light background for image area */
            display: block;
            margin-left: auto;
            margin-right: auto;
            cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s, opacity 0.3s;
        }
        .image-pane .filename { margin-top: 8px; font-size: 0.85em; color: var(--text-secondary-color); word-break: break-all; min-height: 2.5em;}

        /* --- CANVAS STYLES --- */
        .image-comparison-area canvas,
        .lightbox-image-container canvas { /* General targeting for canvases in these areas */
            display: block; /* Or inline-block if preferred, but block is common */
            object-fit: contain; /* This won't directly apply but good for semantic consistency */
            background-color: transparent; /* Ensure no default bg interferes */
            transition: opacity 0.4s ease-in-out; /* For smooth fade-in, same as images */
        }

        /* Ensure canvas within panes specifically gets max dimensions */
        .image-pane canvas {
            max-width: 100%;
            max-height: 350px; /* Same as img in pane */
            height: auto; /* Allow aspect ratio to determine actual height */
            margin-left: auto;
            margin-right: auto;
            cursor: pointer;
        }

        /* Lightbox main canvas */
        #lightboxCanvas {
            max-width: 100%;
            max-height: 100%;
        }

        /* Lightbox carousel side canvases */
        #carouselPrevCanvas, #carouselNextCanvas {
            max-width: 100%;
            max-height: 100%;
            /* opacity: 0.6; is already handled by class .carousel-side-image if we add it */
        }
        /* Add .carousel-side-image class to the side canvases for consistent styling */
        #carouselPrevCanvas, #carouselNextCanvas {
            /* opacity: 0.6; */ /* This will be set by JS */
            /* cursor: pointer; */ /* This will be set by JS */
        }


        /* Lightbox slider canvases */
        #sliderCanvas1, #sliderCanvas2, #sliderCanvas3 {
            /* position, opacity, z-index are already inline, but ensure they behave like images */
            width: 100%; /* Will be sized by lightboxSliderContent */
            height: 100%; /* Will be sized by lightboxSliderContent */
        }

        .error-placeholder { /* Also used as loading placeholder text */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 100px; /* Ensure it takes up space */
            height: 350px; /* Match max-height of img */
            max-height: 350px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-secondary-color);
            color: var(--text-secondary-color);
            font-size: 0.9em;
            box-sizing: border-box;
            padding: 10px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .loading-spinner {
            border: 4px solid var(--spinner-light-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto; /* Default margin */
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- LIGHTBOX STYLES --- */
        .lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--lightbox-bg);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 1001; 
            padding: 20px; 
            box-sizing: border-box;
        }
        .lightbox-overlay.active { display: flex; }

        .lightbox-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .lightbox-image-container {
            width: 100%;
            height: calc(100% - 80px); /* Space for controls */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; 
            position: relative; /* For lightbox spinner positioning and slider view */
        }

        .lightbox-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: transform 0.2s ease-out, opacity 0.3s ease-out;
            transform-origin: center center;
            cursor: grab;
        }
        .lightbox-image.grabbing { cursor: grabbing; }

        .lightbox-image-spinner { /* Spinner specifically for lightbox image */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1; /* Above image while loading */
        }

        .lightbox-close, .lightbox-nav {
            position: absolute;
            background-color: var(--lightbox-nav-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            user-select: none;
            z-index: 10; 
        }
        .lightbox-close:hover, .lightbox-nav:hover { background-color: var(--lightbox-nav-hover-bg); }

        .lightbox-close { top: 15px; right: 15px; }
        .lightbox-prev { left: 15px; top: 50%; transform: translateY(-50%); }
        .lightbox-next { right: 15px; top: 50%; transform: translateY(-50%); }

        .lightbox-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--lightbox-nav-bg);
            padding: 8px 12px;
            border-radius: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 10;
        }
        .lightbox-controls button {
            background: none;
            border: none;
            color: var(--button-text-color);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }
        .lightbox-controls button:hover:not(:disabled) { opacity: 0.8; }
        .lightbox-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
        .lightbox-zoom-level { color: var(--button-text-color); font-size: 0.9em; }

        .lightbox-caption {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--button-text-color);
            background-color: var(--lightbox-nav-bg);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9em;
            text-align: center;
            max-width: 70%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 10;
        }
        .image-title {
            color: var(--accent-color);
            font-weight: bold;
        }
        .lightbox-key-legend {
            position: absolute;
            top: 15px; 
            left: 15px;
            background-color: var(--lightbox-nav-bg);
            color: var(--button-text-color);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em; 
            z-index: 10; 
            max-width: 220px; 
            opacity: 0.85; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            user-select: none;
        }
        .lightbox-key-legend h4 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em; 
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding-bottom: 5px;
            font-weight: 600;
        }
        .lightbox-key-legend ul { list-style: none; padding: 0; margin: 0; }
        .lightbox-key-legend li { margin-bottom: 4px; display: flex; align-items: center; }
        .lightbox-key-legend li:last-child { margin-bottom: 0; }
        .lightbox-key-legend kbd {
            display: inline-block;
            background-color: rgba(0,0,0,0.4); 
            color: var(--button-text-color); 
            padding: 2px 7px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; 
            font-size: 0.95em; 
            margin-right: 10px; 
            text-align: center;
            min-width: 15px; 
        }
        /* --- LIGHTBOX SLIDER STYLES --- */
        #lightboxSliderView {
            /* display: none; set by JS */
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex; /* Will be set to flex by JS when active */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Important */
        }
        #lightboxSliderContent {
            position: relative;
            /* width and height set by JS */
            box-shadow: 0 0 10px rgba(0,0,0,0.5); /* Optional: to delineate the image area */
            user-select: none;
        }
        .slider-comparison-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Relative to lightboxSliderContent */
            height: 100%; /* Relative to lightboxSliderContent */
            object-fit: contain; /* Should be already contained by parent, but good fallback */
            pointer-events: none; /* So they don't interfere with handle dragging */
            /* Clip-path will be applied by JS */
        }
        .slider-handle {
            position: absolute;
            background-color: var(--slider-handle-bg);
            box-shadow: 0 0 3px var(--slider-handle-shadow);
            z-index: 15; /* Above slider images */
            touch-action: none; /* For touch devices */
        }
        .slider-handle.vertical {
            width: 6px;
            height: 100%;
            cursor: ew-resize;
            transform: translateX(-50%); /* Center the handle line */
        }
        .slider-handle.horizontal {
            width: 100%;
            height: 6px;
            cursor: ns-resize;
            transform: translateY(-50%); /* Center the handle line */
        }
        .slider-handle::before { /* Grip indicator */
            content: "";
            position: absolute;
            background-color: var(--text-color);
            opacity: 0.5;
        }
        .slider-handle.vertical::before {
            width: 2px; height: 30px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
         .slider-handle.horizontal::before {
            width: 30px; height: 2px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        .skeleton-placeholder {
            background-color: var(--bg-tertiary-color);
            position: relative; /* Needed for the ::before pseudo-element */
            overflow: hidden;   /* Keep the animation contained */
        }
        .skeleton-placeholder::before {
            content: "";
            position: absolute;
            top: 0;
            left: -150%; /* Start off-screen to the left */
            height: 100%;
            width: 150%; /* Make it wide enough to sweep across */
            background: linear-gradient(
                to right,
                transparent 0%,
                var(--bg-secondary-color) 50%, /* Or a slightly lighter shade of tertiary */
                transparent 100%
            );
            animation: skeleton-sweep 1.8s infinite linear;
            opacity: 0.5; /* Adjust shimmer opacity */
        }

        @keyframes skeleton-sweep {
            0% {
                left: -150%;
            }
            100% {
                left: 100%; /* Sweep to the right */
            }
        }

        .lightbox-image, .carousel-side-image, .slider-comparison-image {
            transition: opacity 0.4s ease-in-out; /* For smooth fade-in */
            background-color: transparent; /* Ensure no default bg interferes */
        }

        /* Ensure images within their containers are properly sized if wrappers are used */
        .carousel-side-image-container img,
        #carouselCurrentImageContainer img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .slider-comparison-image { /* Ensure these are also correctly layered if placeholders are absolute */
            position: absolute; /* If its placeholder is also absolute and covers 100% */
            top: 0; left: 0;
            /* width and height are set by JS or inherited if wrapper is used */
        }


        /* --- API KEY MODAL STYLES --- */
        .api-key-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .api-key-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .api-key-modal-content {
            background-color: var(--bg-color);
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 5px 20px var(--box-shadow-color);
            text-align: center;
            width: 90%;
            max-width: 500px; /* Slightly wider for two inputs */
            color: var(--text-color);
        }
        .api-key-modal-content h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        .api-key-modal-content p {
            margin-bottom: 20px;
            font-size: 0.95em;
            color: var(--text-secondary-color);
        }
        .api-key-modal-content .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        .api-key-modal-content .form-button {
            width: 100%;
            padding: 12px 20px;
            margin-top: 10px;
            background-color: var(--accent-color);
        }
        .api-key-modal-content .form-button:hover {
            background-color: var(--accent-hover-color);
        }
        .api-key-modal-content .status-message {
            margin-top: 15px;
            min-height: 1.2em;
        }


        /* --- FANCY NOTICE STYLES --- */
        .fancy-notice-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 3000; /* Higher than API key modal, lower than potential future super-modals */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            padding-top: 20px; /* Some space from the very top */
            pointer-events: none; /* Allow clicks to pass through overlay itself */
            opacity: 0;
            visibility: hidden;
            transform: translateY(-100%);
            transition: opacity 0.5s ease, visibility 0s linear 0.5s, transform 0.5s ease-out;
        }

        .fancy-notice-overlay.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            transition: opacity 0.5s ease, visibility 0s linear 0s, transform 0.5s ease-in-out;
        }

        .fancy-notice-content {
            background-color: var(--accent-color); /* Or choose a specific notice color */
            color: var(--button-text-color);
            padding: 15px 30px;
            border-radius: 0 0 8px 8px; /* Rounded bottom corners */
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            text-align: center;
            font-size: 1.1em;
            font-weight: 500;
            max-width: 80%; /* Or 100% if you prefer edge-to-edge text container */
            pointer-events: auto; /* Enable clicks on the notice content itself */
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .fancy-notice-content .loading-spinner { /* Style for spinner inside notice */
            width: 24px;
            height: 24px;
            border-width: 3px;
            border-top-color: var(--button-text-color); /* Make spinner contrast with notice bg */
            margin: 0; /* Reset default margin */
        }
        
        .fancy-notice-content.notice-error {
            background-color: var(--error-color);
        }

        .fancy-notice-content.notice-success {
            background-color: var(--success-color);
        }
        
        .fancy-notice-content.notice-warning {
            background-color: #ffc107; /* A typical warning yellow, adjust if needed */
            color: #333; /* Darker text for yellow background */
        }
        .fancy-notice-content.notice-warning .loading-spinner {
             border-top-color: #333;
        }


        @keyframes notice-slide-in {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes notice-slide-out {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-120%); opacity: 0; } /* Slide out a bit further */
        }
    </style>
</head>
<body>
    <button id="themeToggleButton" title="Toggle Theme">🌓</button>

    <!-- API Key Modal -->
    <div id="apiKeyModalOverlay" class="api-key-modal-overlay">
        <div class="api-key-modal-content">
            <h2>Setup API Access</h2>
            <p>Provide your REST Database endpoint URL and API Key.</p>
            <div class="form-group">
                <label for="dbUrlInput">Database URL (Albums Endpoint):</label>
                <input type="url" id="dbUrlInput" placeholder="e.g., https://your-db.restdb.io/rest/albums">
            </div>
            <div class="form-group">
                <label for="apiKeyInput">API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your API key">
            </div>
            <button id="submitApiKeyBtn" class="form-button">Unlock Application</button>
            <div id="apiKeyStatusMsg" class="status-message"></div>
            <div id="apiKeyLoadingSpinner" class="loading-spinner" style="display:none;"></div>
        </div>
    </div>

    <!-- Main Application Container -->
    <div class="container content-locked">
        <h1 id="main-title"></h1>

        <div class="tab-navigation">
            <button class="tab-button active" data-tab="compareTab">Compare Albums</button>
            <button class="tab-button" data-tab="manageTab">Manage Albums</button>
        </div>

        <div id="compareTab" class="tab-content active">
             <h2>Select Albums for Comparison (Up to 3)</h2>
            <div class="album-selection-container">
                <div id="albumListContainer">
                    <p id="albumListLoadingMsg">Loading albums...</p>
                    <div id="albumListLoadingSpinner" class="loading-spinner" style="display:none;"></div>
                    <ul id="albumList"></ul>
                </div>
                <button id="loadSelectedAlbumsBtn" class="form-button" style="margin-top:15px; background-color: var(--accent-color);">Load Selected for Comparison</button>
                <p id="selectionInfo" class="status-message"></p>
            </div>
            <div class="controls">
                <button id="prevBtn" disabled>« Previous</button>
                <span id="imageIndicator">0 / 0</span>
                <button id="nextBtn" disabled>Next »</button>
                <button id="mainShareBtn" class="form-button" style="margin-left: 15px; background-color: var(--success-color);" title="Share Current Album View" disabled>🔗 Share View</button> <!-- ADDED -->
            </div>
            <div class="image-comparison-area">
                <div id="imagePane1" class="image-pane">
                    <h3 id="albumTitle1">Album 1</h3>
                    <div id="img1Placeholder" class="error-placeholder">Select an album</div>
                    <img id="img1" src="#" alt="Image from Album 1" style="display:none;">
                    <canvas id="canvas1" style="max-width: 100%; max-height: 350px; display: none;"></canvas>
                    <p id="img1Name" class="filename">-</p>
                </div>
                <div id="imagePane2" class="image-pane">
                    <h3 id="albumTitle2">Album 2</h3>
                    <div id="img2Placeholder" class="error-placeholder">Select an album</div>
                    <img id="img2" src="#" alt="Image from Album 2" style="display:none;">
                    <canvas id="canvas2" style="max-width: 100%; max-height: 350px; display: none;"></canvas>
                    <p id="img2Name" class="filename">-</p>
                </div>
                <div id="imagePane3" class="image-pane">
                    <h3 id="albumTitle3">Album 3</h3>
                    <div id="img3Placeholder" class="error-placeholder">Select an album</div>
                    <img id="img3" src="#" alt="Image from Album 3" style="display:none;">
                    <canvas id="canvas3" style="max-width: 100%; max-height: 350px; display: none;"></canvas>
                    <p id="img3Name" class="filename">-</p>
                </div>
            </div>
        </div>

        <div id="manageTab" class="tab-content">
            <h2>Create New Album</h2>
            <div class="album-form-container">
                <div class="form-group">
                    <label for="albumTitle">Album Title:</label>
                    <input type="text" id="albumTitleInput" required>
                </div>
                <div class="form-group">
                    <label for="albumDescription">Description (Optional):</label>
                    <textarea id="albumDescriptionInput"></textarea>
                </div>
                <div class="form-group">
                    <label for="albumImageUrls">Image URLs (One per line, direct links):</label>
                    <textarea id="albumImageUrlsInput" placeholder="https://i.ibb.co/your-image1.jpg
https://i.imgur.com/your-image2.jpeg
https://example.com/your-image3.png" required></textarea>
                </div>
                <button id="createAlbumBtn" class="form-button">Create Album</button>
                <div id="createAlbumStatus" class="status-message"></div>
                <div id="createAlbumSpinner" class="loading-spinner" style="display:none;"></div>
            </div>
            <h2>Existing Albums</h2>
            <p style="text-align:center; color: var(--text-secondary-color);">(New albums will appear in the "Compare Albums" tab automatically.)</p>
        </div>
    </div>

    <div id="lightboxOverlay" class="lightbox-overlay">
        <div class="lightbox-content">
            <div id="lightboxKeyLegend" class="lightbox-key-legend">
                <h4>Keyboard Shortcuts</h4>
                <ul>
                    <li><kbd>Esc</kbd> Close</li>
                    <!-- Swapped Arrow and Shift+Arrow functionality -->
                    <li><kbd>←</kbd> Prev Image Set</li>
                    <li><kbd>→</kbd> Next Image Set</li>
                    <li><kbd>Shift</kbd>+<kbd>←</kbd> Prev Image (in set)</li>
                    <li><kbd>Shift</kbd>+<kbd>→</kbd> Next Image (in set)</li>
                    <!-- End Swapped -->
                    <li><kbd>+</kbd> Zoom In</li>
                    <li><kbd>-</kbd> Zoom Out</li>
                    <li><kbd>0</kbd> Reset View</li>
                    <li><kbd>S</kbd> Toggle Sliders</li>
                    <li><kbd>Wheel</kbd> Zoom</li>
                    <li><kbd>Drag</kbd> Move (Zoomed)</li>
                </ul>
            </div>
            <span id="lightboxCaption" class="lightbox-caption">Image Title</span>
            <button id="lightboxClose" class="lightbox-close" title="Close (Esc)">×</button>
            
            <div class="lightbox-image-container">
                <div id="lightboxCarousel" style="display: none; width: 100%; height: 100%; align-items: center; justify-content: space-around; position: relative;">
                    <div class="carousel-side-image-container" style="max-width: 20%; max-height: 70%; position: relative; display:flex; align-items:center; justify-content:center;">
                        <div class="skeleton-placeholder" id="carouselPrevImagePlaceholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                        <img id="carouselPrevImage" class="carousel-side-image" src="#" alt="Previous Image" style="cursor:pointer; opacity:0.6; max-width: 100%; max-height: 100%; object-fit: contain; transition: opacity 0.3s ease-in-out; position:relative; z-index:2; display:none;"> <!-- MODIFIED: Add display:none initially -->
                        <canvas id="carouselPrevCanvas" class="carousel-side-image" style="cursor:pointer; opacity:0.6; max-width: 100%; max-height: 100%; object-fit: contain; transition: opacity 0.3s ease-in-out; position:relative; z-index:2; display:none;"></canvas> <!-- ADDED -->
                    </div>

                    <!-- For lightboxImage (central) -->
                    <div id="carouselCurrentImageContainer" style="flex-grow: 1; height: 100%; max-width:55%; display:flex; align-items:center; justify-content:center; position: relative;">
                        <div class="skeleton-placeholder" id="lightboxImagePlaceholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                        <img id="lightboxImage" class="lightbox-image" src="#" alt="Current Lightbox Image" style="max-width: 100%; max-height: 100%; object-fit: contain; cursor: grab; opacity:0; position:relative; z-index:2; display:none;"> <!-- MODIFIED: Add display:none initially -->
                        <canvas id="lightboxCanvas" class="lightbox-image" style="max-width: 100%; max-height: 100%; object-fit: contain; cursor: grab; opacity:0; position:relative; z-index:2; display:none;"></canvas> <!-- ADDED -->
                        <div id="carouselCurrentImageSpinner" class="loading-spinner" style="display:none; position:absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; z-index:3;"></div>
                    </div>

                    <!-- For carouselNextImage -->
                    <div class="carousel-side-image-container" style="max-width: 20%; max-height: 70%; position: relative; display:flex; align-items:center; justify-content:center;">
                        <div class="skeleton-placeholder" id="carouselNextImagePlaceholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                        <img id="carouselNextImage" class="carousel-side-image" src="#" alt="Next Image" style="cursor:pointer; opacity:0.6; max-width: 100%; max-height: 100%; object-fit: contain; transition: opacity 0.3s ease-in-out; position:relative; z-index:2; display:none;"> <!-- MODIFIED: Add display:none initially -->
                        <canvas id="carouselNextCanvas" class="carousel-side-image" style="cursor:pointer; opacity:0.6; max-width: 100%; max-height: 100%; object-fit: contain; transition: opacity 0.3s ease-in-out; position:relative; z-index:2; display:none;"></canvas> <!-- ADDED -->
                    </div>
                </div>

                <!-- General Lightbox Spinner (for mode switches, initial slider load) -->
                <div id="lightboxImageSpinner" class="loading-spinner lightbox-image-spinner" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);"></div>

                <!-- Slider Comparison Elements -->
                <div id="lightboxSliderView" style="display: none;"> <!-- Managed by JS -->
                    <div id="lightboxSliderContent"> <!-- This will be sized to the 'contained' image -->
                        <div class="slider-image-wrapper" style="position:absolute; top:0; left:0; width:100%; height:100%;">
                            <div class="skeleton-placeholder" id="sliderImg1Placeholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                            <img id="sliderImg1" class="slider-comparison-image" src="#" style="opacity:0; z-index:2; position:absolute; display:none;"> <!-- MODIFIED: Add display:none -->
                            <canvas id="sliderCanvas1" class="slider-comparison-image" style="opacity:0; z-index:2; position:absolute; display:none;"></canvas> <!-- ADDED -->
                        </div>
                        <div class="slider-image-wrapper" style="position:absolute; top:0; left:0; width:100%; height:100%;">
                            <div class="skeleton-placeholder" id="sliderImg2Placeholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                            <img id="sliderImg2" class="slider-comparison-image" src="#" style="opacity:0; z-index:2; position:absolute; display:none;"> <!-- MODIFIED: Add display:none -->
                            <canvas id="sliderCanvas2" class="slider-comparison-image" style="opacity:0; z-index:2; position:absolute; display:none;"></canvas> <!-- ADDED -->
                        </div>
                        <div class="slider-image-wrapper" style="position:absolute; top:0; left:0; width:100%; height:100%;">
                            <div class="skeleton-placeholder" id="sliderImg3Placeholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                            <img id="sliderImg3" class="slider-comparison-image" src="#" style="display:none; opacity:0; z-index:2; position:absolute; display:none;"> <!-- MODIFIED: Add display:none (it was already there, ensure it is) -->
                            <canvas id="sliderCanvas3" class="slider-comparison-image" style="display:none; opacity:0; z-index:2; position:absolute; display:none;"></canvas> <!-- ADDED -->
                        </div>
                        <!-- Note: The clip-path will be applied to the wrapper or the image directly.
                            If applied to wrapper, ensure image inside is 100% width/height of wrapper.
                            If applied to image, wrapper is just for placeholder. Simpler to apply to image.
                            The current structure has clip-path on image, so adding placeholder as sibling is fine.
                            Let's stick to applying clip-path to the image itself for now.
                            The above HTML for slider images might be too complex with wrappers. Let's simplify:
                        -->
                        <!-- Corrected Slider Images HTML (placeholders as direct siblings of images) -->
                        <!-- Inside #lightboxSliderContent -->
                        <div class="skeleton-placeholder" id="sliderImg1Placeholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                        <img id="sliderImg1" class="slider-comparison-image" src="#" style="opacity:0; z-index:2; position:absolute;"> <!-- Ensure position:absolute for stacking -->

                        <div class="skeleton-placeholder" id="sliderImg2Placeholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                        <img id="sliderImg2" class="slider-comparison-image" src="#" style="opacity:0; z-index:2; position:absolute;">

                        <div class="skeleton-placeholder" id="sliderImg3Placeholder" style="display:none; position: absolute; width:100%; height:100%; background-color: var(--bg-tertiary-color); z-index:1;"></div>
                        <img id="sliderImg3" class="slider-comparison-image" src="#" style="display:none; opacity:0; z-index:2; position:absolute;">
                        <div id="sliderHandle1" class="slider-handle" style="display:none;"></div>
                        <div id="sliderHandle2" class="slider-handle" style="display:none;"></div>
                    </div>
                </div>
            </div>
            <div class="lightbox-controls">
                <!-- Updated titles for set navigation buttons -->
                <button id="lightboxPrevSetBtn" title="Previous Image Set (Left Arrow)">⬅️ Prev Set</button>
                <button id="lightboxZoomOut" title="Zoom Out (-)">➖</button>
                <span id="lightboxZoomLevel" class="lightbox-zoom-level">100%</span>
                <button id="lightboxZoomIn" title="Zoom In (+)">➕</button>
                <button id="lightboxZoomReset" title="Reset Zoom (0)">🔄</button>
                <button id="lightboxSliderToggleBtn" title="Toggle Slider Comparison (S)">🎚️</button>
                <button id="lightboxShareBtn" title="Share Current Comparison (copies link)">🔗</button>
                <button id="lightboxNextSetBtn" title="Next Image Set (Right Arrow)">Next Set ➡️</button>
            </div>
        </div>
    </div>

    <script>
        const version = document.querySelector('meta[name="app-version"]').getAttribute('content');
        document.getElementById('main-title').textContent = `Batch Image Comparer (v${version})`;

        let userApiKey = null;
        let userDbUrl = null; // Will be set after validation
        const DEFAULT_DB_URL = 'https://batchimagecomparer-1d67.restdb.io/rest/albums';

        let imageDimensionCache = {}; // To store { url: { width, height, loaded: true/false, error: true/false } }
        let imagePreloadManager = { // To manage preloading Image objects
            cache: {}, // { url: ImageObject }
            isLoading: new Set() // URLs currently being loaded by this manager
        };
        const CANVAS_MAX_DIMENSION = 4096; // Safety for very large images on canvas

        const MAX_SELECTED_ALBUMS = 3;

        const mainContainer = document.querySelector('.container');
        const apiKeyModalOverlay = document.getElementById('apiKeyModalOverlay');
        const dbUrlInput = document.getElementById('dbUrlInput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const submitApiKeyBtn = document.getElementById('submitApiKeyBtn');
        const apiKeyStatusMsg = document.getElementById('apiKeyStatusMsg');
        const apiKeyLoadingSpinner = document.getElementById('apiKeyLoadingSpinner');

        const themeToggleButton = document.getElementById('themeToggleButton');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const albumTitleInput = document.getElementById('albumTitleInput');
        const albumDescriptionInput = document.getElementById('albumDescriptionInput');
        const albumImageUrlsInput = document.getElementById('albumImageUrlsInput');
        const createAlbumBtn = document.getElementById('createAlbumBtn');
        const createAlbumStatus = document.getElementById('createAlbumStatus');
        const createAlbumSpinner = document.getElementById('createAlbumSpinner');
        const albumListUL = document.getElementById('albumList');
        const albumListLoadingMsg = document.getElementById('albumListLoadingMsg');
        const albumListLoadingSpinner = document.getElementById('albumListLoadingSpinner');
        const loadSelectedAlbumsBtn = document.getElementById('loadSelectedAlbumsBtn');
        const selectionInfo = document.getElementById('selectionInfo');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const mainShareBtn = document.getElementById('mainShareBtn'); // ADDED
        const imageIndicator = document.getElementById('imageIndicator');

        const imagePanes = [
            { id: 'imagePane1', el: document.getElementById('imagePane1'), titleEl: document.getElementById('albumTitle1'), imgEl: document.getElementById('img1'), canvasEl: document.getElementById('canvas1'), placeholderEl: document.getElementById('img1Placeholder'), nameEl: document.getElementById('img1Name'), urls: [], albumData: null }, // ADDED canvasEl
            { id: 'imagePane2', el: document.getElementById('imagePane2'), titleEl: document.getElementById('albumTitle2'), imgEl: document.getElementById('img2'), canvasEl: document.getElementById('canvas2'), placeholderEl: document.getElementById('img2Placeholder'), nameEl: document.getElementById('img2Name'), urls: [], albumData: null }, // ADDED canvasEl
            { id: 'imagePane3', el: document.getElementById('imagePane3'), titleEl: document.getElementById('albumTitle3'), imgEl: document.getElementById('img3'), canvasEl: document.getElementById('canvas3'), placeholderEl: document.getElementById('img3Placeholder'), nameEl: document.getElementById('img3Name'), urls: [], albumData: null }  // ADDED canvasEl
        ];

        const lightboxOverlay = document.getElementById('lightboxOverlay');
        const lightboxImage = document.getElementById('lightboxImage');
        const lightboxImageContainer = document.querySelector('.lightbox-image-container');
        const lightboxImageSpinner = document.getElementById('lightboxImageSpinner');
        const lightboxCaption = document.getElementById('lightboxCaption');
        const lightboxCloseBtn = document.getElementById('lightboxClose');
        const lightboxZoomInBtn = document.getElementById('lightboxZoomIn');
        const lightboxZoomOutBtn = document.getElementById('lightboxZoomOut');
        const lightboxZoomResetBtn = document.getElementById('lightboxZoomReset');
        const lightboxZoomLevel = document.getElementById('lightboxZoomLevel');
        const lightboxSliderToggleBtn = document.getElementById('lightboxSliderToggleBtn');

        // Carousel specific elements
        const lightboxCarousel = document.getElementById('lightboxCarousel'); // NEW
        const carouselPrevImage = document.getElementById('carouselPrevImage'); // NEW
        // const lightboxImage = document.getElementById('lightboxImage'); // This already exists and now refers to the central carousel image
        const carouselCurrentImageSpinner = document.getElementById('carouselCurrentImageSpinner'); // NEW
        const carouselNextImage = document.getElementById('carouselNextImage'); // NEW

        // Placeholders
        const lightboxImagePlaceholder = document.getElementById('lightboxImagePlaceholder');
        const carouselPrevImagePlaceholder = document.getElementById('carouselPrevImagePlaceholder');
        const carouselNextImagePlaceholder = document.getElementById('carouselNextImagePlaceholder');
        const sliderImg1Placeholder = document.getElementById('sliderImg1Placeholder');
        const sliderImg2Placeholder = document.getElementById('sliderImg2Placeholder');
        const sliderImg3Placeholder = document.getElementById('sliderImg3Placeholder');

        // Lightbox Slider Elements
        const lightboxSliderView = document.getElementById('lightboxSliderView');
        const lightboxSliderContent = document.getElementById('lightboxSliderContent');
        const sliderImg1 = document.getElementById('sliderImg1');
        const sliderImg2 = document.getElementById('sliderImg2');
        const sliderImg3 = document.getElementById('sliderImg3');
        const sliderHandle1 = document.getElementById('sliderHandle1');
        const sliderHandle2 = document.getElementById('sliderHandle2');
        const lightboxShareBtn = document.getElementById('lightboxShareBtn');
        const lightboxPrevSetBtn = document.getElementById('lightboxPrevSetBtn'); // ADDED
        const lightboxNextSetBtn = document.getElementById('lightboxNextSetBtn'); // ADDED

        const lightboxCanvas = document.getElementById('lightboxCanvas');
        const carouselPrevCanvas = document.getElementById('carouselPrevCanvas');
        const carouselNextCanvas = document.getElementById('carouselNextCanvas');

        const sliderCanvas1 = document.getElementById('sliderCanvas1');
        const sliderCanvas2 = document.getElementById('sliderCanvas2');
        const sliderCanvas3 = document.getElementById('sliderCanvas3');

        let allAlbums = [];
        let selectedAlbumIds = [];
        let currentPairIndex = 0;
        let totalComparablePairs = 0;

        let lightboxCurrentScale = 1;
        const ZOOM_STEP = 0.2;
        const MAX_ZOOM = 5;
        const MIN_ZOOM = 0.2;
        let lightboxActivePanesForView = []; // Panes used for current lightbox view (single or slider)
        let lightboxCurrentImagePaneIndex = 0; // Index within lightboxActivePanesForView for single view
        let lightboxDragStartX, lightboxDragStartY;
        let lightboxIsDragging = false;
        let lightboxImgInitialX = 0; 
        let lightboxImgInitialY = 0;
        let carouselCurrentImageSetIndex = 0;

        let lastKnownMouseX = 0;
        let lastKnownMouseY = 0;
        let animationFrameRequested = false;

        // Slider State
        let isSliderModeActive = false;
        let sliderNumImages = 0;
        let sliderOrientation = 'vertical'; // 'vertical' (sliders move L/R) or 'horizontal' (sliders move U/D)
        let sliderRenderedWidth = 0;
        let sliderRenderedHeight = 0;
        let slider1Percent = 50; // Position as percentage
        let slider2Percent = 66.67; // Position as percentage
        let activeSliderHandle = null;
        let sliderDragStartPos = 0;
        let sharedAlbumIdsToLoad = null;
        let sharedIndexToLoad = null;
        let isProcessingSharedLink = false;
        let sharedInitialSliderMode = false; // ADDED: To store slider mode preference from URL
        let sharedViewContext = 'main';     // ADDED: To store if lightbox should auto-open ('lightbox' or 'main')
        let sharedPrimaryAlbumId = null; // ADDED: To store the ID of the album that was primarily in view
        let lastCarouselIndexBeforeSlider = 0;


        // --- API Key Modal Logic ---
        function showApiKeyModal() {
            mainContainer.classList.add('content-locked');
            apiKeyModalOverlay.classList.add('active');
            dbUrlInput.value = localStorage.getItem('userProvidedDbUrl') || DEFAULT_DB_URL; // Pre-fill DB URL
            apiKeyInput.focus();
        }

        function hideApiKeyModal() {
            apiKeyModalOverlay.classList.remove('active');
            mainContainer.classList.remove('content-locked');
        }

        async function validateApiAccess(keyToTest, dbUrlToTest, isFromStorage = false) {
            apiKeyStatusMsg.textContent = '';
            apiKeyStatusMsg.className = 'status-message';
            apiKeyLoadingSpinner.style.display = 'block';
            submitApiKeyBtn.disabled = true;

            const validationEndpoint = '?metafields=count'; // Fetches only the count of records
            const fullValidationUrl = dbUrlToTest.endsWith('/') ? dbUrlToTest.slice(0, -1) + validationEndpoint : dbUrlToTest + validationEndpoint;


            try {
                const response = await fetch(fullValidationUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-apikey': keyToTest,
                        'cache-control': 'no-cache'
                    }
                });

                if (response.ok) {
                    userApiKey = keyToTest;
                    userDbUrl = dbUrlToTest;
                    localStorage.setItem('userProvidedApiKey', keyToTest);
                    localStorage.setItem('userProvidedDbUrl', dbUrlToTest);
                    apiKeyStatusMsg.textContent = 'API access validated successfully!';
                    apiKeyStatusMsg.className = 'status-message status-success';
                    setTimeout(() => {
                        hideApiKeyModal();
                        initializeAppLogic();
                    }, 500);
                } else {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    throw new Error(`Validation failed: ${response.status} - ${errorData.message || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('API Access Validation Error:', error);
                let userMessage = `Invalid API Key or DB URL. ${error.message.includes('NetworkError') || error.message.includes('Failed to fetch') ? 'Network error or CORS issue.' : error.message.replace('Validation failed: ', '')}. Please check both and try again.`;
                if (error.message.includes('SyntaxError')) { // Often from trying to parse non-JSON as JSON, can happen with wrong DB URL.
                    userMessage = `Invalid DB URL format or non-JSON response. Ensure the URL points to a valid REST Database collection endpoint.`;
                }
                apiKeyStatusMsg.textContent = userMessage;
                apiKeyStatusMsg.className = 'status-message status-error';
                if (isFromStorage) {
                    localStorage.removeItem('userProvidedApiKey');
                    localStorage.removeItem('userProvidedDbUrl');
                }
                userApiKey = null;
                userDbUrl = null;
                if (!apiKeyModalOverlay.classList.contains('active')) {
                    showApiKeyModal();
                }
            } finally {
                apiKeyLoadingSpinner.style.display = 'none';
                submitApiKeyBtn.disabled = false;
            }
        }

        submitApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            const dbUrl = dbUrlInput.value.trim() || DEFAULT_DB_URL; // Use default if empty

            if (!dbUrl) { // Should not happen with default, but as a safeguard
                 apiKeyStatusMsg.textContent = 'Please enter a Database URL.';
                 apiKeyStatusMsg.className = 'status-message status-error';
                 return;
            }
             try { // Validate URL format client-side (basic)
                new URL(dbUrl);
            } catch (_) {
                apiKeyStatusMsg.textContent = 'Invalid Database URL format.';
                apiKeyStatusMsg.className = 'status-message status-error';
                return;
            }
            if (key) {
                validateApiAccess(key, dbUrl);
            } else {
                apiKeyStatusMsg.textContent = 'Please enter an API Key.';
                apiKeyStatusMsg.className = 'status-message status-error';
            }
        });

        apiKeyInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitApiKeyBtn.click(); });
        dbUrlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitApiKeyBtn.click(); });


        function checkAndPromptForApiAccess() {
            const storedApiKey = localStorage.getItem('userProvidedApiKey');
            const storedDbUrl = localStorage.getItem('userProvidedDbUrl');
            if (storedApiKey && storedDbUrl) {
                dbUrlInput.value = storedDbUrl; // Ensure it's displayed if modal re-opens
                apiKeyInput.value = storedApiKey; // For user convenience if validation fails
                validateApiAccess(storedApiKey, storedDbUrl, true);
            } else {
                showApiKeyModal();
            }
        }

        // --- Main App Initialization ---
        function initializeAppLogic() {
            const activeTabButton = document.querySelector('.tab-button.active');
            let currentTab = activeTabButton ? activeTabButton.dataset.tab : 'compareTab';

            if (isProcessingSharedLink && currentTab !== 'compareTab') {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                const compareTabBtn = document.querySelector('.tab-button[data-tab="compareTab"]');
                const compareTabContent = document.getElementById('compareTab');
                if (compareTabBtn) compareTabBtn.classList.add('active');
                if (compareTabContent) compareTabContent.classList.add('active');
                currentTab = 'compareTab';
            }
            
            const loadDataAndFinalize = async () => {
                if ((currentTab === 'compareTab' || isProcessingSharedLink) && allAlbums.length === 0 && userApiKey && userDbUrl) {
                    albumListLoadingMsg.style.display = 'block';
                    albumListLoadingMsg.textContent = 'Loading albums for comparison...';
                    albumListLoadingSpinner.style.display = 'block';
                    try {
                        await fetchAlbums();
                    } catch (e) {
                        albumListLoadingMsg.textContent = `Error loading albums: ${e.message}`;
                        albumListLoadingSpinner.style.display = 'none';
                    }
                }

                if (isProcessingSharedLink && sharedAlbumIdsToLoad && sharedIndexToLoad !== null) {
                    if (allAlbums.length > 0) {
                        await loadSharedComparison(sharedAlbumIdsToLoad, sharedIndexToLoad);
                    } else {
                        const statusElement = document.getElementById('sharedLoadStatus');
                        if(statusElement) statusElement.textContent = "Error: Could not load albums. Shared comparison cannot be processed.";
                        console.error("Cannot load shared comparison: allAlbums is empty.");
                        setTimeout(() => statusElement?.remove(), 5000);
                        isProcessingSharedLink = false;
                    }
                } else {
                    updateComparisonDisplay();
                }
            };

            loadDataAndFinalize();
        }


        // --- FANCY NOTICE HELPERS ---
        let fancyNoticeElement = null;
        let fancyNoticeTextElement = null;
        let fancyNoticeSpinnerElement = null;
        let fancyNoticeTimeoutId = null;

        function createFancyNotice() {
            if (fancyNoticeElement) return; // Already created

            fancyNoticeElement = document.createElement('div');
            fancyNoticeElement.id = 'fancyNoticeOverlay';
            fancyNoticeElement.className = 'fancy-notice-overlay';

            const content = document.createElement('div');
            content.className = 'fancy-notice-content';
            
            fancyNoticeSpinnerElement = document.createElement('div');
            fancyNoticeSpinnerElement.className = 'loading-spinner';
            fancyNoticeSpinnerElement.style.display = 'none'; // Hide by default

            fancyNoticeTextElement = document.createElement('span');
            fancyNoticeTextElement.id = 'fancyNoticeText';

            content.appendChild(fancyNoticeSpinnerElement);
            content.appendChild(fancyNoticeTextElement);
            fancyNoticeElement.appendChild(content);
            document.body.appendChild(fancyNoticeElement);
        }

        function showFancyNotice(message, type = 'info', showSpinner = false, duration = null) {
            createFancyNotice(); // Ensure it exists

            fancyNoticeTextElement.textContent = message;
            const contentElement = fancyNoticeElement.querySelector('.fancy-notice-content');
            
            // Reset classes
            contentElement.classList.remove('notice-error', 'notice-success', 'notice-warning');

            if (type === 'error') {
                contentElement.classList.add('notice-error');
            } else if (type === 'success') {
                contentElement.classList.add('notice-success');
            } else if (type === 'warning') {
                contentElement.classList.add('notice-warning');
            }
            // 'info' uses default accent color

            fancyNoticeSpinnerElement.style.display = showSpinner ? 'block' : 'none';
            
            fancyNoticeElement.classList.add('visible');

            if (fancyNoticeTimeoutId) {
                clearTimeout(fancyNoticeTimeoutId);
            }

            if (duration) {
                fancyNoticeTimeoutId = setTimeout(() => {
                    hideFancyNotice();
                }, duration);
            }
        }

        function updateFancyNotice(message, type = 'info', showSpinner = false, duration = null) {
             if (!fancyNoticeElement || !fancyNoticeElement.classList.contains('visible')) {
                showFancyNotice(message, type, showSpinner, duration);
                return;
            }
            // If already visible, just update content
            fancyNoticeTextElement.textContent = message;
            const contentElement = fancyNoticeElement.querySelector('.fancy-notice-content');
            contentElement.classList.remove('notice-error', 'notice-success', 'notice-warning');
             if (type === 'error') contentElement.classList.add('notice-error');
             else if (type === 'success') contentElement.classList.add('notice-success');
             else if (type === 'warning') contentElement.classList.add('notice-warning');

            fancyNoticeSpinnerElement.style.display = showSpinner ? 'block' : 'none';

            if (fancyNoticeTimeoutId) clearTimeout(fancyNoticeTimeoutId);
            if (duration) {
                fancyNoticeTimeoutId = setTimeout(hideFancyNotice, duration);
            }
        }


        function hideFancyNotice() {
            if (fancyNoticeElement) {
                fancyNoticeElement.classList.remove('visible');
                 if (fancyNoticeTimeoutId) {
                    clearTimeout(fancyNoticeTimeoutId);
                    fancyNoticeTimeoutId = null;
                }
                setTimeout(() => {
                if (!fancyNoticeElement.classList.contains('visible')) {
                fancyNoticeElement.remove();
                fancyNoticeElement = null;
                }
                }, 600); // A bit longer than CSS transition
            }
        }

        // --- THEME ---
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
                themeToggleButton.textContent = '☀️';
                themeToggleButton.title = 'Switch to Light Theme';
            } else {
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = '🌓';
                themeToggleButton.title = 'Switch to Dark Theme';
            }
        }

        function toggleTheme() {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        }
        themeToggleButton.addEventListener('click', toggleTheme);

        // --- TABS ---
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                const newActiveTabContent = document.getElementById(button.dataset.tab);
                if (newActiveTabContent) newActiveTabContent.classList.add('active');
                
                // MODIFIED: Always fetch albums when switching to the 'Compare Albums' tab
                // to ensure the list is up-to-date after potential changes in 'Manage Albums'.
                if (button.dataset.tab === 'compareTab' && userApiKey && userDbUrl) {
                    fetchAlbums(); // This will re-fetch and re-render the album list.
                                   // selectedAlbumIds will be cleared as part of renderAlbumList.
                }
            });
        });

        // --- CANVASES ---

        function drawImageOnCanvasWithContain(canvas, img, isSideCarousel = false) {
            if (!canvas || !img || !img.naturalWidth || !img.naturalHeight) {
                console.error("drawImageOnCanvasWithContain: Missing canvas, image, or image not loaded.", canvas, img);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                return;
            }

            const ctx = canvas.getContext('2d');
            const imgAspectRatio = img.naturalWidth / img.naturalHeight;

            let canvasContainerWidth, canvasContainerHeight;

            if (canvas.id.startsWith('canvas')) { // Main panes
                canvasContainerWidth = canvas.parentElement.clientWidth;
                canvasContainerHeight = 350; // Max height from CSS
            } else if (canvas.id === 'lightboxCanvas') {
                canvasContainerWidth = lightboxImageContainer.clientWidth;
                canvasContainerHeight = lightboxImageContainer.clientHeight;
            } else if (canvas.id === 'carouselPrevCanvas' || canvas.id === 'carouselNextCanvas') {
                const LICKW = lightboxImageContainer.clientWidth;
                const LICKH = lightboxImageContainer.clientHeight;

                if (LICKW === 0 || LICKH === 0) {
                    console.warn(`Lightbox image container has zero dimensions when drawing ${canvas.id}. W: ${LICKW}, H: ${LICKH}. Falling back.`);
                    // Fallback to canvas.offsetWidth or image natural dimensions if LICK is not ready
                    // This might still result in small images if offsetWidth is small, but it's a last resort.
                    canvasContainerWidth = canvas.offsetWidth || img.naturalWidth;
                    canvasContainerHeight = canvas.offsetHeight || img.naturalHeight;
                } else {
                    // .carousel-side-image-container is max 20% width, 70% height of lightboxImageContainer.
                    // The canvas inside it is max 100% of that. So these are the effective max dimensions for the canvas content.
                    canvasContainerWidth = LICKW * 0.20;
                    canvasContainerHeight = LICKH * 0.70;
                }
            } else if (canvas.id.startsWith('sliderCanvas')) {
                canvasContainerWidth = lightboxSliderContent.clientWidth;
                canvasContainerHeight = lightboxSliderContent.clientHeight;
            } else { // Fallback for any other canvas
                canvasContainerWidth = canvas.clientWidth || canvas.width;
                canvasContainerHeight = canvas.clientHeight || canvas.height;
            }
            
            // This existing fallback is still useful if the above calculations yield zero for some reason.
            if (canvasContainerWidth === 0 || canvasContainerHeight === 0) {
                canvasContainerWidth = canvas.offsetWidth || img.naturalWidth;
                canvasContainerHeight = canvas.offsetHeight || img.naturalHeight;
                 if (canvasContainerWidth === 0 || canvasContainerHeight === 0) { // If still zero, can't draw
                    console.error("Cannot determine container dimensions for canvas:", canvas.id);
                    return;
                }
            }

            const containerAspectRatio = canvasContainerWidth / canvasContainerHeight;
            let drawWidth, drawHeight;

            if (imgAspectRatio > containerAspectRatio) {
                drawWidth = canvasContainerWidth;
                drawHeight = drawWidth / imgAspectRatio;
            } else {
                drawHeight = canvasContainerHeight;
                drawWidth = drawHeight * imgAspectRatio;
            }

            drawWidth = Math.min(drawWidth, CANVAS_MAX_DIMENSION, img.naturalWidth); // Also cap by naturalWidth
            drawHeight = Math.min(drawHeight, CANVAS_MAX_DIMENSION, img.naturalHeight); // Also cap by naturalHeight
            
            // Ensure draw dimensions are at least 1px to avoid errors if calculations result in zero or negative
            drawWidth = Math.max(1, drawWidth);
            drawHeight = Math.max(1, drawHeight);

            canvas.width = drawWidth;
            canvas.height = drawHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            canvas.style.opacity = (isSideCarousel && !canvas.matches(':hover')) ? '0.6' : '1';
            canvas.style.display = 'block';

            if (canvas.id === 'lightboxCanvas' && !isSliderModeActive) {
                applyLightboxCanvasTransform();
            }
        }

        function applyLightboxCanvasTransform() {
            if (isSliderModeActive || !lightboxCanvas) return;
            // Get current translation from lightboxImage (the hidden one used for drag calcs)
            let unscaledX = 0, unscaledY = 0;
            const currentTransform = lightboxImage.style.transform; // lightboxImage is still used for drag logic state
            const translateMatch = currentTransform.match(/translate\(([^p]+)px, ([^p]+)px\)/);
            if (translateMatch) {
                unscaledX = parseFloat(translateMatch[1]);
                unscaledY = parseFloat(translateMatch[2]);
            }
            lightboxCanvas.style.transform = `translate(${unscaledX}px, ${unscaledY}px) scale(${lightboxCurrentScale})`;
            lightboxCanvas.style.cursor = lightboxCurrentScale > 1 ? 'grab' : 'default';
        }

        // --- PLACEHOLDERS ---
        function setImageWithPlaceholder(imgElement, canvasElement, placeholderElement, spinnerElement, url, isSideCarousel = false, forSlider = false) {
            if (!imgElement || !canvasElement || !placeholderElement) {
                console.error("setImageWithPlaceholder: Critical element missing for URL:", url);
                return;
            }

            const ctx = canvasElement.getContext('2d');

            // --- IMMEDIATE RESET FOR NEW URL ---
            // Regardless of previous state, if a new URL is coming, reset related elements.
            // This is crucial to prevent previous image/error states from lingering.
            imgElement.onload = null; // Detach old handlers
            imgElement.onerror = null;
            if (imgElement.src && imgElement.src !== "about:blank" && imgElement.src !== "#") { // If it was loading something
                imgElement.src = "#"; // Stop any previous load
            }
            imgElement.removeAttribute('src');


            canvasElement.style.display = 'none';
            canvasElement.style.opacity = '0';
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            placeholderElement.style.backgroundColor = 'var(--bg-tertiary-color)'; // Reset placeholder color
            placeholderElement.textContent = ''; // Clear text initially
            placeholderElement.style.display = 'block'; // Show skeleton placeholder by default

            if (spinnerElement) spinnerElement.style.display = 'block';
            // --- END IMMEDIATE RESET ---

            if (!url) { // No URL provided, show appropriate empty state
                if (spinnerElement) spinnerElement.style.display = 'none';
                placeholderElement.textContent = forSlider ? '' : (isSideCarousel ? '' : 'Select an album');
                if (canvasElement.id.startsWith('canvas')) placeholderElement.textContent = 'No image for comparison'; // Main pane specific

                imgElement.dataset.currentSrc = ""; // Clear dataset
                imgElement.dataset.loadError = "false";
                if (imageDimensionCache[url]) delete imageDimensionCache[url];
                return;
            }

            // Set this unique ID for the current loading operation on this element combination
            const loadOperationId = Date.now() + Math.random();
            imgElement.dataset.loadOperationId = loadOperationId;
            imgElement.dataset.currentSrc = url; // Set currentSrc *before* assigning src
            imgElement.dataset.loadError = "false";


            // --- Placeholder Text & Sizing ---
            // Set "Loading..." text on placeholder if we are actually going to load
            placeholderElement.textContent = 'Loading image...';

            // Attempt to size placeholder if dimensions are known (from cache)
            if (imageDimensionCache[url] && imageDimensionCache[url].loaded && imageDimensionCache[url].width && imageDimensionCache[url].height) {
                const dims = imageDimensionCache[url];
                const containerWidth = canvasElement.parentElement.clientWidth;
                const cssMaxHeight = parseInt(getComputedStyle(canvasElement).maxHeight) || Infinity;

                const targetWidth = Math.min(dims.width, containerWidth || dims.width);
                const targetHeight = Math.min(dims.height, cssMaxHeight || dims.height);
                
                // Basic aspect ratio for placeholder (this is still a rough fit)
                // A better way is CSS aspect-ratio property if you can set it on the placeholder
                placeholderElement.style.width = `${targetWidth}px`;
                placeholderElement.style.height = `${targetHeight}px`;
                // For lightbox, placeholders are full size of their containers
                if (canvasElement === lightboxCanvas || canvasElement === carouselPrevCanvas || canvasElement === carouselNextCanvas || forSlider) {
                    placeholderElement.style.width = '100%';
                    placeholderElement.style.height = '100%';
                }
            } else {
                // Default placeholder sizing if no dimensions (relies on existing CSS for .error-placeholder)
                // For lightbox, ensure placeholders take up their intended space
                if (canvasElement === lightboxCanvas || canvasElement === carouselPrevCanvas || canvasElement === carouselNextCanvas || forSlider) {
                    placeholderElement.style.width = '100%';
                    placeholderElement.style.height = '100%';
                } else {
                    // For main panes, let existing CSS define placeholder size
                    placeholderElement.style.width = ''; // Reset to CSS default
                    placeholderElement.style.height = '';// Reset to CSS default
                }
            }
            // --- End Placeholder Text & Sizing ---

            // Check our preload manager
            if (imagePreloadManager.cache[url] && imagePreloadManager.cache[url].complete && imagePreloadManager.cache[url].naturalWidth > 0) {
                const preloadedImg = imagePreloadManager.cache[url];
                // imgElement.dataset still needs to reflect this URL for consistency, already set above.
                imageDimensionCache[url] = {
                    width: preloadedImg.naturalWidth,
                    height: preloadedImg.naturalHeight,
                    loaded: true,
                    error: false
                };

                if (spinnerElement) spinnerElement.style.display = 'none';
                placeholderElement.style.display = 'none';
                drawImageOnCanvasWithContain(canvasElement, preloadedImg, isSideCarousel);

                if (imgElement === lightboxImage) resetLightboxZoomAndPosition();
                return;
            }

            // If not preloaded, proceed with normal load via the hidden imgElement
            imgElement.onload = () => {
                // CRITICAL CHECK: Only proceed if this onload corresponds to the *current* operation for this imgElement
                if (imgElement.dataset.loadOperationId !== loadOperationId.toString() || imgElement.dataset.currentSrc !== url) {
                    // console.warn("Stale onload event ignored for:", url, "on element:", imgElement.id);
                    return;
                }

                imageDimensionCache[url] = {
                    width: imgElement.naturalWidth,
                    height: imgElement.naturalHeight,
                    loaded: true,
                    error: false
                };
                if (imagePreloadManager.isLoading.has(url)) imagePreloadManager.isLoading.delete(url);
                imagePreloadManager.cache[url] = imgElement; // Cache the actual img element that loaded

                if (spinnerElement) spinnerElement.style.display = 'none';
                placeholderElement.style.display = 'none';
                drawImageOnCanvasWithContain(canvasElement, imgElement, isSideCarousel);

                if (imgElement === lightboxImage) resetLightboxZoomAndPosition();
            };

            imgElement.onerror = () => {
                // CRITICAL CHECK:
                if (imgElement.dataset.loadOperationId !== loadOperationId.toString() || imgElement.dataset.currentSrc !== url) {
                    // console.warn("Stale onerror event ignored for:", url, "on element:", imgElement.id);
                    return;
                }
                console.error("Error loading image:", url, "for element:", imgElement.id);
                imageDimensionCache[url] = { error: true, loaded: false, width: 0, height: 0 }; // Store error
                if (imagePreloadManager.isLoading.has(url)) imagePreloadManager.isLoading.delete(url);

                if (spinnerElement) spinnerElement.style.display = 'none';
                placeholderElement.style.display = 'flex'; // Ensure placeholder is visible for error
                placeholderElement.style.backgroundColor = 'var(--error-color)';
                placeholderElement.textContent = 'Load Error';
                canvasElement.style.display = 'none';
                imgElement.dataset.loadError = 'true';
            };

            // Assign src to start loading. This MUST be the last step related to imgElement.src
            imgElement.src = url;
        }
        
        // --- API CALLS ---
        async function apiCall(endpoint = '', method = 'GET', body = null) {
            if (!userApiKey || !userDbUrl) {
                console.error('API call attempted without valid API key or DB URL.');
                showApiKeyModal(); 
                throw new Error('API Key or DB URL not available. Please provide valid credentials.');
            }
            // Ensure userDbUrl doesn't have trailing slash if endpoint also starts with one or is empty
            const base = userDbUrl.endsWith('/') ? userDbUrl.slice(0, -1) : userDbUrl;
            const fullUrl = endpoint ? (base + (endpoint.startsWith('/') ? endpoint : '/' + endpoint)) : base;

            const options = {
                method: method,
                headers: { 'Content-Type': 'application/json', 'x-apikey': userApiKey, 'cache-control': 'no-cache' }
            };
            if (body) options.body = JSON.stringify(body);
            try {
                const response = await fetch(fullUrl, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    if (response.status === 401 || response.status === 404) { // 404 could mean wrong DB URL
                        let msg = `API Key/DB URL seems invalid or has insufficient permissions. (${errorData.message})`;
                        if (response.status === 404) msg = `Database URL endpoint not found. Please check the URL. (${errorData.message})`;
                        
                        apiKeyStatusMsg.textContent = msg;
                        apiKeyStatusMsg.className = 'status-message status-error';
                        localStorage.removeItem('userProvidedApiKey');
                        localStorage.removeItem('userProvidedDbUrl');
                        userApiKey = null;
                        userDbUrl = null;
                        showApiKeyModal();
                    }
                    throw new Error(`API Error: ${response.status} - ${errorData.message || 'Unknown error'}`);
                }
                return await response.json();
            } catch (error) { 
                console.error('API Call Failed:', error); 
                if (!error.message.includes('API Key or DB URL not available')) { 
                    // Further generic error display if needed, but 401/404 above handles credential issues
                }
                throw error; 
            }
        }

        // --- ALBUM MANAGEMENT ---
        async function fetchAlbums() {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; } 
            albumListLoadingMsg.style.display = 'block';
            albumListLoadingMsg.textContent = 'Loading albums...';
            albumListLoadingSpinner.style.display = 'block';
            albumListUL.innerHTML = '';
            try {
                allAlbums = await apiCall(''); // Endpoint is empty for base DB URL
                renderAlbumList();
                albumListLoadingMsg.style.display = 'none';
            } catch (error) {
                albumListLoadingMsg.textContent = `Error loading albums: ${error.message}`;
                albumListLoadingMsg.style.color = 'var(--error-color)';
            } finally { albumListLoadingSpinner.style.display = 'none'; }
        }

        async function createAlbum(albumData) {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; } 
            createAlbumStatus.textContent = '';
            createAlbumSpinner.style.display = 'block';
            try {
                const newAlbum = await apiCall('', 'POST', albumData); // Endpoint is empty
                createAlbumStatus.textContent = `Album "${newAlbum.title}" created successfully!`;
                createAlbumStatus.className = 'status-message status-success';
                albumTitleInput.value = ''; albumDescriptionInput.value = ''; albumImageUrlsInput.value = '';
            } catch (error) {
                createAlbumStatus.textContent = `Error creating album: ${error.message}`;
                createAlbumStatus.className = 'status-message status-error';
            } finally { createAlbumSpinner.style.display = 'none'; }
        }

        createAlbumBtn.addEventListener('click', () => {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; }
            const title = albumTitleInput.value.trim();
            const description = albumDescriptionInput.value.trim();
            const urlsText = albumImageUrlsInput.value.trim();
            if (!title || !urlsText) {
                createAlbumStatus.textContent = 'Title and Image URLs are required.';
                createAlbumStatus.className = 'status-message status-error'; return;
            }
            const imageUrls = urlsText.split('\n').map(url => url.trim()).filter(url => url.length > 0 && (url.startsWith('http://') || url.startsWith('https://')));
            if (imageUrls.length === 0) {
                createAlbumStatus.textContent = 'Please provide at least one valid image URL.';
                createAlbumStatus.className = 'status-message status-error'; return;
            }
            createAlbum({ title, description, imageUrls });
        });

        function renderAlbumList() {
            albumListUL.innerHTML = '';
            if (allAlbums.length === 0) {
                albumListUL.innerHTML = '<li>No albums found. Create one in the "Manage Albums" tab.</li>'; return;
            }
            allAlbums.sort((a,b) => a.title.localeCompare(b.title)).forEach(album => {
                const li = document.createElement('li');
                li.dataset.albumId = album._id;
                li.setAttribute('role', 'option');
                li.setAttribute('aria-selected', selectedAlbumIds.includes(album._id) ? 'true' : 'false');

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = selectedAlbumIds.includes(album._id);
                checkbox.setAttribute('tabindex', '-1');

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'album-item-details';
                
                const titleSpan = document.createElement('span');
                titleSpan.className = 'album-item-title';
                titleSpan.textContent = album.title;
                
                const descSpan = document.createElement('span');
                descSpan.className = 'album-item-desc';
                const fullDesc = album.description ? album.description : 'No description';
                descSpan.dataset.fullDescription = fullDesc; 
                descSpan.textContent = fullDesc; 

                const countSpan = document.createElement('span');
                countSpan.className = 'album-item-count';
                countSpan.textContent = `(${album.imageUrls ? album.imageUrls.length : 0} images)`;

                detailsDiv.appendChild(titleSpan);
                detailsDiv.appendChild(descSpan);
                li.appendChild(checkbox);
                li.appendChild(detailsDiv);
                li.appendChild(countSpan);
                albumListUL.appendChild(li);

                li.addEventListener('click', (event) => {
                    if (event.target.tagName === 'INPUT' && event.target.type === 'checkbox') {
                    } else {
                        checkbox.checked = !checkbox.checked; 
                    }
                    li.setAttribute('aria-selected', checkbox.checked ? 'true' : 'false');
                    handleAlbumSelection(album._id, checkbox.checked);
                    
                    if (!(event.target.tagName === 'INPUT' && event.target.type === 'checkbox')) {
                         descSpan.classList.toggle('expanded');
                    }
                });
            });
        }

        function handleAlbumSelection(albumId, isChecked) {
            const listItem = albumListUL.querySelector(`li[data-album-id="${albumId}"]`);
            if (isChecked) {
                if (selectedAlbumIds.length < MAX_SELECTED_ALBUMS) {
                    if (!selectedAlbumIds.includes(albumId)) selectedAlbumIds.push(albumId);
                    if (listItem) listItem.setAttribute('aria-selected', 'true');
                } else if (!selectedAlbumIds.includes(albumId)) { 
                    const checkbox = listItem ? listItem.querySelector('input[type="checkbox"]') : null;
                    if (checkbox) checkbox.checked = false;
                    if (listItem) listItem.setAttribute('aria-selected', 'false');
                    selectionInfo.textContent = `You can select a maximum of ${MAX_SELECTED_ALBUMS} albums.`;
                    selectionInfo.className = 'status-message status-error';
                    setTimeout(() => { selectionInfo.textContent = ''; }, 3000);
                }
            } else {
                selectedAlbumIds = selectedAlbumIds.filter(id => id !== albumId);
                if (listItem) listItem.setAttribute('aria-selected', 'false');
            }
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const numSelected = selectedAlbumIds.length;
            selectionInfo.textContent = numSelected > 0 ? `${numSelected} album(s) selected.` : '';
            selectionInfo.className = numSelected > 0 ? 'status-message status-success' : 'status-message';
        }

        loadSelectedAlbumsBtn.addEventListener('click', () => {
            if (!userApiKey || !userDbUrl) { showApiKeyModal(); return; }
            imagePanes.forEach(pane => {
                pane.urls = []; pane.albumData = null; pane.el.classList.remove('active');
                clearImagePane(pane, 'Select an album');
            });
            if (selectedAlbumIds.length === 0) {
                selectionInfo.textContent = 'Please select at least one album.';
                selectionInfo.className = 'status-message status-error';
                totalComparablePairs = 0; updateComparisonDisplay(); return;
            }
            selectionInfo.textContent = '';
            let activePaneIndex = 0;
            selectedAlbumIds.forEach(id => {
                const album = allAlbums.find(a => a._id === id);
                if (album && activePaneIndex < MAX_SELECTED_ALBUMS) {
                    const pane = imagePanes[activePaneIndex];
                    pane.urls = album.imageUrls || []; pane.albumData = album;
                    pane.el.classList.add('active'); pane.titleEl.textContent = album.title;
                    activePaneIndex++;
                }
            });
            for (let i = activePaneIndex; i < MAX_SELECTED_ALBUMS; i++) { imagePanes[i].el.classList.remove('active'); }
            prepareComparison();
        });

        // --- IMAGE COMPARISON & DISPLAY ---
        function getFileNameFromUrl(url) {
            if (!url || typeof url !== 'string') return "Invalid URL";
            try { const path = new URL(url).pathname; const parts = path.split('/'); return decodeURIComponent(parts[parts.length - 1]) || url; }
            catch (e) { const parts = url.split('/'); return parts[parts.length - 1] || url; }
        }

        function prepareComparison() {
            const activePanesWithUrls = imagePanes.filter(p => p.albumData && p.urls.length > 0 && p.el.classList.contains('active'));
            totalComparablePairs = activePanesWithUrls.length > 0 ? Math.min(...activePanesWithUrls.map(p => p.urls.length)) : 0;
            currentPairIndex = 0;
            updateComparisonDisplay();
        }

        function clearImagePane(pane, message = "No image loaded") {
            pane.imgEl.src = "#"; // Still good to clear the hidden loader
            pane.imgEl.style.display = 'none';
            // pane.imgEl.style.opacity = '1'; // Not relevant as it's hidden

            if (pane.canvasEl) {
                const ctx = pane.canvasEl.getContext('2d');
                ctx.clearRect(0, 0, pane.canvasEl.width, pane.canvasEl.height);
                pane.canvasEl.style.display = 'none'; // Hide canvas
            }

            pane.placeholderEl.textContent = message;
            pane.placeholderEl.style.display = 'flex';
            pane.nameEl.textContent = "-";
            if (pane.canvasEl) pane.canvasEl.onclick = null; // Clear click from canvas
            // pane.imgEl.onclick = null; // imgEl is hidden
        }

        function setImageForPane(pane, url, paneGlobalIndex) {
            if (!pane.canvasEl) {
                console.error("Canvas element missing for pane:", pane.id);
                clearImagePane(pane, 'Configuration error');
                return;
            }

            // Show loading state on placeholder BEFORE calling setImageWithPlaceholder
            pane.placeholderEl.textContent = 'Loading image...';
            pane.placeholderEl.style.display = 'flex'; // Ensure placeholder is visible
            pane.canvasEl.style.display = 'none';   // Hide canvas while loading starts
            pane.nameEl.textContent = url ? getFileNameFromUrl(url) : "-"; // Set name early

            if (!url) {
                clearImagePane(pane, pane.albumData ? 'No image at this index' : 'No album loaded');
                // The clearImagePane function already handles hiding canvas and showing placeholder.
                return;
            }

            // The new setImageWithPlaceholder handles showing placeholder/spinner internally now.
            // We pass null for spinnerElement for main panes as per original design.
            // If you want spinners on main panes, you'd need to add spinner elements to the HTML for each pane
            // and pass their references here.
            setImageWithPlaceholder(pane.imgEl, pane.canvasEl, pane.placeholderEl, null /* spinnerElement for main pane */, url);

            // Click handler should be on the canvas now
            pane.canvasEl.onclick = () => openLightbox(paneGlobalIndex, currentPairIndex);

            // Preload next and previous images for the main view
            if (pane.urls && pane.urls.length > 1) {
                if (currentPairIndex < pane.urls.length - 1) {
                    preloadImage(pane.urls[currentPairIndex + 1]);
                }
                if (currentPairIndex > 0) {
                    preloadImage(pane.urls[currentPairIndex - 1]);
                }
            }
        }

        function preloadImage(url) {
            if (!url || imagePreloadManager.cache[url] || imagePreloadManager.isLoading.has(url)) {
                return; // Already cached, loading, or no URL
            }

            // console.log('Preloading:', url);
            imagePreloadManager.isLoading.add(url);
            const img = new Image();
            img.onload = () => {
                // console.log('Preloaded successfully:', url);
                imagePreloadManager.cache[url] = img;
                imagePreloadManager.isLoading.delete(url);
                // Store dimensions from preloaded image
                imageDimensionCache[url] = {
                    width: img.naturalWidth,
                    height: img.naturalHeight,
                    loaded: true,
                    error: false
                };
            };
            img.onerror = () => {
                console.error('Failed to preload:', url);
                imagePreloadManager.isLoading.delete(url);
                imageDimensionCache[url] = { error: true, loaded: false };
                // Don't store failed preloads in imagePreloadManager.cache
            };
            img.src = url;
        }

        // ADD THIS NEW FUNCTION - to clear preload cache if albums change significantly
        function clearImagePreloadCache() {
            imagePreloadManager.cache = {};
            imagePreloadManager.isLoading.clear();
            // imageDimensionCache = {}; // Optionally clear dimension cache too, or keep it more persistent
        }

        function updateComparisonDisplay() {
            const activeLoadedPanes = imagePanes.filter(p => p.albumData && p.el.classList.contains('active'));
            const panesWithImagesForCurrentIndex = activeLoadedPanes.filter(p => p.urls && p.urls.length > currentPairIndex);

            let canShareMainView = false; // ADDED

            if (totalComparablePairs > 0 && panesWithImagesForCurrentIndex.length > 0) {
                imageIndicator.textContent = `${currentPairIndex + 1} / ${totalComparablePairs}`;
                prevBtn.disabled = currentPairIndex === 0;
                nextBtn.disabled = currentPairIndex === totalComparablePairs - 1;
                activeLoadedPanes.forEach((pane, index) => {
                     setImageForPane(pane, pane.urls[currentPairIndex], imagePanes.indexOf(pane));
                });
                canShareMainView = true; // ADDED
            } else {
                imageIndicator.textContent = `0 / 0`; prevBtn.disabled = true; nextBtn.disabled = true;
                let singleAlbumNavPossible = false;
                activeLoadedPanes.forEach((pane) => {
                    const paneGlobalIndex = imagePanes.indexOf(pane);
                    if (pane.albumData && pane.urls && pane.urls.length > 0 && activeLoadedPanes.filter(p => p.urls && p.urls.length > 0).length === 1) {
                        setImageForPane(pane, pane.urls[currentPairIndex], paneGlobalIndex);
                        imageIndicator.textContent = `${currentPairIndex + 1} / ${pane.urls.length}`;
                        prevBtn.disabled = currentPairIndex === 0;
                        nextBtn.disabled = currentPairIndex >= pane.urls.length - 1;
                        singleAlbumNavPossible = true;
                        canShareMainView = true; // ADDED
                    } else if (pane.albumData && (!pane.urls || pane.urls.length === 0)) { clearImagePane(pane, 'Album has no images');
                    } else if (pane.albumData) { clearImagePane(pane, 'No image for comparison');
                    } else { clearImagePane(pane, 'No album loaded'); }
                });
                if (!singleAlbumNavPossible) { prevBtn.disabled = true; nextBtn.disabled = true; imageIndicator.textContent = `0 / 0`; }
            }
            updateSliderToggleButton(); // For lightbox slider button
            mainShareBtn.disabled = !canShareMainView; // ADDED: Enable/disable main share button
        }

        // ADDED FUNCTION for main page sharing
        function generateAndCopyMainShareLink() {
            const activeComparisonPanes = imagePanes
                .filter(p => p.el.classList.contains('active') && p.albumData && p.urls && p.urls.length > currentPairIndex);

            if (activeComparisonPanes.length === 0) {
                alert("No active albums with images at the current index to share.");
                mainShareBtn.innerHTML = '🔗 Share View'; // Reset button text if it was "Copied!"
                mainShareBtn.disabled = imageIndicator.textContent === '0 / 0';
                return;
            }
            
            const albumIdsToShare = activeComparisonPanes.map(pane => pane.albumData._id);
            const shareIndex = currentPairIndex;
            const primaryAlbumIdForShare = activeComparisonPanes[0].albumData._id;


            const params = new URLSearchParams();
            params.set('shareAlbums', albumIdsToShare.join(','));
            params.set('shareIndex', shareIndex.toString());
            params.set('primaryAlbumId', primaryAlbumIdForShare); 
            params.set('viewContext', 'main'); // EXPLICITLY ADDED/CORRECTED for main page shares

            // sliderMode is not relevant for main page share context for auto-opening

            const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;

            navigator.clipboard.writeText(shareUrl).then(() => {
                const originalText = mainShareBtn.textContent;
                mainShareBtn.textContent = 'Copied!';
                mainShareBtn.disabled = true;
                setTimeout(() => {
                    mainShareBtn.textContent = '🔗 Share View';
                    // Re-evaluate disable state based on whether images are loaded
                    const anyActivePanes = imagePanes.some(p => p.el.classList.contains('active') && p.albumData && p.urls.length > 0);
                    mainShareBtn.disabled = !anyActivePanes || imageIndicator.textContent === '0 / 0';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy main share link: ', err);
                prompt("Failed to copy. Please copy this link manually:", shareUrl);
                mainShareBtn.innerHTML = '🔗 Share View'; // Reset on error
                const anyActivePanes = imagePanes.some(p => p.el.classList.contains('active') && p.albumData && p.urls.length > 0);
                mainShareBtn.disabled = !anyActivePanes || imageIndicator.textContent === '0 / 0';
            });
        }

        async function loadSharedComparison(idsFromUrl, indexToLoad) { // Renamed 'ids' to 'idsFromUrl' for clarity

            if (!allAlbums || allAlbums.length === 0) {
                updateFancyNotice("Error: Album list is empty. Cannot process shared link.", 'error', false, 7000);
                isProcessingSharedLink = false;
                sharedAlbumIdsToLoad = null; 
                sharedIndexToLoad = null;
                sharedInitialSliderMode = false; 
                sharedViewContext = 'main';
                sharedPrimaryAlbumId = null;
                return;
            }

            // Ensure Compare Tab is active
            const compareTabBtn = document.querySelector('.tab-button[data-tab="compareTab"]');
            const compareTabContent = document.getElementById('compareTab');
            if (compareTabBtn && !compareTabBtn.classList.contains('active')) {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                compareTabBtn.classList.add('active');
                if (compareTabContent) compareTabContent.classList.add('active');
            }
            
            // Filter allAlbums to get data for albums specified in the URL
            const albumsDataFromUrl = allAlbums.filter(album => idsFromUrl.includes(album._id));
            
            if (albumsDataFromUrl.length === 0) {
                updateFancyNotice("Error: None of the shared albums could be found in the database.", 'error', false, 7000);
                isProcessingSharedLink = false;
                sharedAlbumIdsToLoad = null; 
                sharedIndexToLoad = null;
                sharedInitialSliderMode = false; 
                sharedViewContext = 'main';
                sharedPrimaryAlbumId = null;
                return;
            }
            
            if (albumsDataFromUrl.length < idsFromUrl.length) {
                updateFancyNotice("Warning: Some shared albums were not found. Loading available ones.", 'warning', false, 7000);
            }

            // Set selectedAlbumIds based on the order from the URL,
            // but only using albums that actually exist.
            selectedAlbumIds = idsFromUrl.map(id => albumsDataFromUrl.find(a => a._id === id))
                                      .filter(Boolean) // Remove any undefined if an id from URL wasn't found
                                      .map(album => album._id);
            
            if (selectedAlbumIds.length === 0) {
                updateFancyNotice("Error: None of the album IDs from the shared link were valid or found.", 'error', false, 7000);
                isProcessingSharedLink = false;
                sharedAlbumIdsToLoad = null; 
                sharedIndexToLoad = null;
                sharedInitialSliderMode = false; 
                sharedViewContext = 'main';
                sharedPrimaryAlbumId = null;
                return;
            }

            renderAlbumList(); // Update checkboxes based on new selectedAlbumIds
            updateSelectionInfo();

            // --- Replicate logic from 'loadSelectedAlbumsBtn' click handler, respecting new selectedAlbumIds order ---
            imagePanes.forEach(pane => {
                pane.urls = []; pane.albumData = null; pane.el.classList.remove('active');
                clearImagePane(pane, 'Select an album');
            });

            let activePaneSetupIndex = 0;
            // Populate imagePanes strictly in the order of selectedAlbumIds (which now matches idsFromUrl)
            selectedAlbumIds.forEach(id => {
                const albumData = allAlbums.find(a => a._id === id); // We know it exists
                if (albumData && activePaneSetupIndex < MAX_SELECTED_ALBUMS) {
                    const pane = imagePanes[activePaneSetupIndex];
                    pane.urls = albumData.imageUrls || []; 
                    pane.albumData = albumData;
                    pane.el.classList.add('active'); 
                    pane.titleEl.textContent = albumData.title;
                    activePaneSetupIndex++;
                }
            });
            // Deactivate any remaining panes if fewer than MAX_SELECTED_ALBUMS were loaded
            for (let i = activePaneSetupIndex; i < MAX_SELECTED_ALBUMS; i++) { 
                imagePanes[i].el.classList.remove('active'); 
                clearImagePane(imagePanes[i], 'No album for this slot');
            }
            
            prepareComparison(); // Calculates totalComparablePairs etc. based on newly ordered active panes
            // --- End of replicated logic ---

            // Validate the shared index against the loaded albums
            let maxPossibleIndex = 0;
            // Active panes for comparison, considering the now potentially re-ordered imagePanes
            const activePanesWithContent = imagePanes.filter(p => p.el.classList.contains('active') && p.albumData && p.urls.length > 0);

            if (totalComparablePairs > 0) { // Comparison mode with multiple albums
                maxPossibleIndex = totalComparablePairs - 1;
            } else if (activePanesWithContent.length === 1) { // Single album view
                maxPossibleIndex = activePanesWithContent[0].urls.length - 1;
            } else { // No images to show
                maxPossibleIndex = -1; // Indicates no valid index
            }

            if (indexToLoad >= 0 && indexToLoad <= maxPossibleIndex) {
                currentPairIndex = indexToLoad;
                updateFancyNotice("Shared comparison loaded successfully!", 'success', false, 3000); // Hide after 3s
            } else {
                const warningMsg = `Shared image index (${indexToLoad + 1}) is out of bounds (max: ${maxPossibleIndex + 1}). Displaying first image.`;
                updateFancyNotice(warningMsg, 'warning', false, 7000);
                currentPairIndex = 0;
            }
            
            updateComparisonDisplay();

            // Conditional lightbox opening using sharedPrimaryAlbumId
            if (sharedViewContext === 'lightbox' && !fancyNoticeElement.querySelector('.fancy-notice-content.notice-error')) {
                let paneGlobalIndexToOpen = -1;
                
                // Find the pane that corresponds to the sharedPrimaryAlbumId among the *currently active* panes
                const primaryAlbumPane = imagePanes.find(p => 
                    p.albumData && 
                    p.albumData._id === sharedPrimaryAlbumId && 
                    p.el.classList.contains('active') && // Ensure it's one of the panes we just set up
                    p.urls.length > currentPairIndex     // And it has an image at the current index
                );

                if (primaryAlbumPane) {
                    paneGlobalIndexToOpen = imagePanes.indexOf(primaryAlbumPane);
                } else if (activePanesWithContent.length > 0) {
                    // Fallback: if primaryAlbumId didn't match an active pane (e.g., bad link or album removed),
                    // open the first *active* pane that has content.
                    // The activePanesWithContent is already filtered for active and having URLs.
                    const firstValidActivePane = activePanesWithContent.find(p => p.urls.length > currentPairIndex);
                    if (firstValidActivePane) {
                        paneGlobalIndexToOpen = imagePanes.indexOf(firstValidActivePane);
                    }
                    if (!primaryAlbumPane) {
                         console.warn("Shared primaryAlbumId did not match an active pane. Falling back.");
                    }
                }

                if (paneGlobalIndexToOpen !== -1) {
                     setTimeout(() => { 
                        openLightbox(paneGlobalIndexToOpen, currentPairIndex, { initialSliderMode: sharedInitialSliderMode });
                    }, 200); // Delay to allow main page DOM to update
                } else {
                     console.warn("Could not determine a valid pane to open in lightbox for shared link.");
                     // Potentially show a message to the user if statusElement is still around
                }
            }
            
            // Clear all shared link processing flags and stored data
            isProcessingSharedLink = false; 
            sharedAlbumIdsToLoad = null; 
            sharedIndexToLoad = null;
            sharedInitialSliderMode = false; 
            sharedViewContext = 'main';
            sharedPrimaryAlbumId = null;
        }
        
        prevBtn.addEventListener('click', () => { if (currentPairIndex > 0) { currentPairIndex--; updateComparisonDisplay(); } });
        nextBtn.addEventListener('click', () => {
            let limit = totalComparablePairs;
            const activePanesWithImages = imagePanes.filter(p => p.albumData && p.urls && p.urls.length > 0 && p.el.classList.contains('active'));
            if (activePanesWithImages.length === 1) limit = activePanesWithImages[0].urls.length;
            if (currentPairIndex < limit - 1) { currentPairIndex++; updateComparisonDisplay(); }
        });

        // ADDED HELPER FUNCTION
        function getMaxImageIndex() {
            const activeLoadedPanes = imagePanes.filter(p => p.albumData && p.el.classList.contains('active'));
            // Check for images in *any* of the active loaded panes, not just those at currentPairIndex
            const panesWithAnyImages = activeLoadedPanes.filter(p => p.urls && p.urls.length > 0);

            if (totalComparablePairs > 0) { // Multiple albums in sync for comparison
                return totalComparablePairs -1;
            } else if (panesWithAnyImages.length === 1 && panesWithAnyImages[0].urls) { // Single album loaded with images
                return panesWithAnyImages[0].urls.length -1;
            }
            return -1; // No images to navigate sets for
        }

        // ADDED FUNCTION for lightbox set navigation
        function navigateImageSet(direction) { // For Shift + Arrow keys
            const maxImageOverallIndex = getMaxImageIndex(); // Max value for currentPairIndex
            if (maxImageOverallIndex === -1 && direction !== 0) return; // No sets to navigate to, unless it's a refresh (dir=0)

            const newPairIndex = currentPairIndex + direction;

            if (newPairIndex >= 0 && newPairIndex <= maxImageOverallIndex) {
                currentPairIndex = newPairIndex; // Update the global comparison index
                updateComparisonDisplay();       // Update the main page display

                if (lightboxOverlay.classList.contains('active')) { // If lightbox is open
                    // Store the ID of the album that was in the center of the carousel, to try and keep focus
                    const previouslyFocusedAlbumId = (carouselCurrentImageSetIndex < lightboxActivePanesForView.length && lightboxActivePanesForView[carouselCurrentImageSetIndex])
                                                    ? lightboxActivePanesForView[carouselCurrentImageSetIndex].albumData._id
                                                    : null;

                    // Re-filter lightboxActivePanesForView for the NEW currentPairIndex
                    lightboxActivePanesForView = imagePanes.filter(p =>
                        p.el.classList.contains('active') &&
                        p.albumData && p.albumData.imageUrls &&
                        p.albumData.imageUrls.length > currentPairIndex && // Use the NEW currentPairIndex
                        p.albumData.imageUrls[currentPairIndex]            // Check URL at NEW currentPairIndex
                    );

                    if (lightboxActivePanesForView.length === 0) {
                        // If the new currentPairIndex results in no images for the lightbox set
                        closeLightbox(); // Close lightbox as there's nothing to show for this set
                        return;
                    }
                    
                    // Try to set carouselCurrentImageSetIndex to the same album if it's still in the new set
                    if (previouslyFocusedAlbumId) {
                        const newCarouselIdx = lightboxActivePanesForView.findIndex(p => p.albumData._id === previouslyFocusedAlbumId);
                        if (newCarouselIdx !== -1) {
                            carouselCurrentImageSetIndex = newCarouselIdx;
                        } else {
                            // If previous album is not in the new set, default to the first item
                            carouselCurrentImageSetIndex = 0;
                        }
                    } else {
                         carouselCurrentImageSetIndex = 0; // Default to first image in the new set
                    }
                    
                    // Ensure carouselCurrentImageSetIndex is valid for the potentially changed lightboxActivePanesForView length
                    if (carouselCurrentImageSetIndex >= lightboxActivePanesForView.length) {
                        carouselCurrentImageSetIndex = Math.max(0, lightboxActivePanesForView.length - 1);
                    }

                    updateLightboxView(); // This will call updateCarouselDisplay or setupSliderComparison

                    // Preload images for the new set in the lightbox
                    lightboxActivePanesForView.forEach(paneData => {
                        if (paneData.albumData && paneData.albumData.imageUrls && paneData.albumData.imageUrls[currentPairIndex]) {
                            preloadImage(paneData.albumData.imageUrls[currentPairIndex]);
                        }
                    });
                }
            }
        }

        // --- LIGHTBOX ---
        function openLightbox(paneGlobalIndex, imageIdxInAlbum, options = {}) {
            // imageIdxInAlbum is currentPairIndex from the main page.
            // paneGlobalIndex is the index of the *imagePane* element (0, 1, or 2) that was clicked.

            // lightboxActivePanesForView will hold the pane data for images currently being compared
            // at the given currentPairIndex (imageIdxInAlbum). This forms the "set" for the carousel.
            lightboxActivePanesForView = imagePanes.filter(p =>
                p.el.classList.contains('active') &&        // Is the pane active on the main page?
                p.albumData && p.albumData.imageUrls &&      // Does it have album data and URLs?
                p.albumData.imageUrls.length > imageIdxInAlbum && // Does the album have an image at this index?
                p.albumData.imageUrls[imageIdxInAlbum]       // Is the URL at this index valid?
            );

            if (lightboxActivePanesForView.length === 0) {
                console.error("Cannot open lightbox: No active panes with images at the current index to form a carousel set.");
                return;
            }

            // Determine which item in lightboxActivePanesForView corresponds to the clicked paneGlobalIndex.
            // We need to map the original imagePanes index (paneGlobalIndex) to an index within
            // the filtered lightboxActivePanesForView.
            const clickedPaneOriginalData = imagePanes[paneGlobalIndex];
            carouselCurrentImageSetIndex = lightboxActivePanesForView.findIndex(
                activePane => activePane.albumData._id === clickedPaneOriginalData.albumData._id
            );

            // Fallback if the clicked pane wasn't found in the filtered list (e.g., if it had no image at currentPairIndex)
            // This shouldn't happen if the click came from an image that was successfully loaded on the main page.
            if (carouselCurrentImageSetIndex === -1) {
                // This implies the clicked image pane was not included in lightboxActivePanesForView,
                // which is odd if it was clickable. If this happens, default to the first available.
                console.warn("Clicked pane not found in active lightbox set, defaulting to first.");
                carouselCurrentImageSetIndex = 0;
                 if (lightboxActivePanesForView.length === 0) { // Double check after potential filtering issue
                    closeLightbox(); return;
                }
            }
            
            // currentPairIndex is already globally set to imageIdxInAlbum.

            lightboxOverlay.classList.add('active');
            document.addEventListener('keydown', handleLightboxKeyPress);
            
            const canUseSlider = lightboxActivePanesForView.length >= 2;

            if (options.initialSliderMode && canUseSlider) {
                isSliderModeActive = true;
                localStorage.setItem('lightboxViewMode', 'slider');
            } else {
                const preferredMode = localStorage.getItem('lightboxViewMode');
                if (preferredMode === 'slider' && canUseSlider) {
                    isSliderModeActive = true;
                } else {
                    isSliderModeActive = false; // Default to carousel mode
                    if ((preferredMode === 'slider' && !canUseSlider) || (options.initialSliderMode && !canUseSlider)) {
                         localStorage.setItem('lightboxViewMode', 'single'); // 'single' now means carousel
                    }
                }
            }
            // Fallback if slider mode was chosen/preferred but isn't possible with the current set
            if (isSliderModeActive && !canUseSlider) {
                isSliderModeActive = false;
                localStorage.setItem('lightboxViewMode', 'single');
            }

            updateLightboxView(); 
        }

        function closeLightbox() {
            isSliderModeActive = false;
            if (lightboxSliderView) lightboxSliderView.style.display = 'none';
            [sliderImg1, sliderImg2, sliderImg3].forEach(img => {
                if (img) {
                    img.src = "#"; img.style.opacity = '0';
                    img.dataset.currentSrc = ""; img.dataset.loadError = "false"; // Reset
                }
            });
            [sliderCanvas1, sliderCanvas2, sliderCanvas3].forEach(canvas => { // ADDED
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    canvas.style.display = 'none';
                    canvas.style.opacity = '0';
                }
            });
            [sliderImg1Placeholder, sliderImg2Placeholder, sliderImg3Placeholder].forEach(p => { if (p) p.style.display = 'none'; });

            lightboxOverlay.classList.remove('active');
            document.removeEventListener('keydown', handleLightboxKeyPress);

            if (lightboxImage) {
                lightboxImage.src = "#"; lightboxImage.style.opacity = '0';
                lightboxImage.dataset.currentSrc = ""; lightboxImage.dataset.loadError = "false"; // Reset
            }
            if (lightboxCanvas) { // ADDED
                const ctx = lightboxCanvas.getContext('2d');
                ctx.clearRect(0, 0, lightboxCanvas.width, lightboxCanvas.height);
                lightboxCanvas.style.display = 'none';
                lightboxCanvas.style.opacity = '0';
                lightboxCanvas.style.transform = 'translate(0px, 0px) scale(1)'; // Reset transform
            }
            if (lightboxImagePlaceholder) lightboxImagePlaceholder.style.display = 'none';
            if (carouselCurrentImageSpinner) carouselCurrentImageSpinner.style.display = 'none';

            if (carouselPrevImage) {
                carouselPrevImage.src = "#"; carouselPrevImage.style.opacity = '0';
                carouselPrevImage.dataset.currentSrc = ""; carouselPrevImage.dataset.loadError = "false"; // Reset
            }
            if (carouselPrevCanvas) { // ADDED
                const ctx = carouselPrevCanvas.getContext('2d');
                ctx.clearRect(0, 0, carouselPrevCanvas.width, carouselPrevCanvas.height);
                carouselPrevCanvas.style.display = 'none';
            }
            if (carouselPrevImagePlaceholder) carouselPrevImagePlaceholder.style.display = 'none';

            if (carouselNextImage) {
                carouselNextImage.src = "#"; carouselNextImage.style.opacity = '0';
                carouselNextImage.dataset.currentSrc = ""; carouselNextImage.dataset.loadError = "false"; // Reset
            }
            if (carouselNextCanvas) { // ADDED
                const ctx = carouselNextCanvas.getContext('2d');
                ctx.clearRect(0, 0, carouselNextCanvas.width, carouselNextCanvas.height);
                carouselNextCanvas.style.display = 'none';
            }
            if (carouselNextImagePlaceholder) carouselNextImagePlaceholder.style.display = 'none';

            if (lightboxCarousel) lightboxCarousel.style.display = 'none';
            if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';

            carouselCurrentImageSetIndex = 0;
            lightboxActivePanesForView = [];
            lastCarouselIndexBeforeSlider = 0;
        }
        
        function updateLightboxView() {
            if (!lightboxOverlay.classList.contains('active')) return; // Don't update if lightbox isn't open

            if (isSliderModeActive) {
                if (lightboxCarousel) lightboxCarousel.style.display = 'none';
                if (carouselCurrentImageSpinner) carouselCurrentImageSpinner.style.display = 'none';
                
                lightboxSliderView.style.display = 'flex';
                if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'block'; // Show general spinner for slider setup
                setupSliderComparison(); // This will hide lightboxImageSpinner when done
            } else { // Carousel Mode
                lightboxSliderView.style.display = 'none';
                if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none'; // Hide general spinner
                
                if (lightboxCarousel) lightboxCarousel.style.display = 'flex';
                
                resetLightboxZoomAndPosition(); // Applies to the central image (which is `lightboxImage` element)
                updateCarouselDisplay(); // New function to render the 3-image carousel
            }
            updateLightboxControlsState();
            updateSliderToggleButton();
        }

        function updateCarouselDisplay() {
            if (isSliderModeActive || lightboxActivePanesForView.length === 0 || !lightboxCarousel) {
                if (lightboxCarousel) lightboxCarousel.style.display = 'none';
                if(lightboxImageSpinner && lightboxImageSpinner.style.display !== 'none') lightboxImageSpinner.style.display = 'none';
                return;
            }
            lightboxCarousel.style.display = 'flex';

            if (carouselCurrentImageSetIndex < 0 || carouselCurrentImageSetIndex >= lightboxActivePanesForView.length) {
                carouselCurrentImageSetIndex = Math.max(0, Math.min(carouselCurrentImageSetIndex, lightboxActivePanesForView.length - 1));
                if (lightboxActivePanesForView.length === 0) { closeLightbox(); return; }
            }

            const currentPaneDataInSet = lightboxActivePanesForView[carouselCurrentImageSetIndex];
            let centralImageUrl = null;
            let centralImageTitle = "Error: Image data missing";

            if (currentPaneDataInSet && currentPaneDataInSet.albumData && currentPaneDataInSet.albumData.imageUrls &&
                currentPaneDataInSet.albumData.imageUrls.length > currentPairIndex &&
                currentPaneDataInSet.albumData.imageUrls[currentPairIndex]) {
                centralImageUrl = currentPaneDataInSet.albumData.imageUrls[currentPairIndex];
                centralImageTitle = `${currentPaneDataInSet.albumData.title} - ${getFileNameFromUrl(centralImageUrl)} (Image ${currentPairIndex + 1} from album, Set Item ${carouselCurrentImageSetIndex + 1}/${lightboxActivePanesForView.length})`;
            }
            
            setImageWithPlaceholder(
                lightboxImage,      // Hidden <img> loader
                lightboxCanvas,     // Visible <canvas>
                lightboxImagePlaceholder,
                carouselCurrentImageSpinner,
                centralImageUrl
            );
            lightboxCaption.textContent = centralImageTitle;

            // Previous Image in Carousel
            let prevImageUrl = null;
            if (carouselCurrentImageSetIndex > 0) {
                const prevPaneDataInSet = lightboxActivePanesForView[carouselCurrentImageSetIndex - 1];
                if (prevPaneDataInSet && prevPaneDataInSet.albumData.imageUrls.length > currentPairIndex && prevPaneDataInSet.albumData.imageUrls[currentPairIndex]) {
                    prevImageUrl = prevPaneDataInSet.albumData.imageUrls[currentPairIndex];
                }
            }
            setImageWithPlaceholder(
                carouselPrevImage,
                carouselPrevCanvas,
                carouselPrevImagePlaceholder,
                null,
                prevImageUrl,
                true // isSideCarousel
            );
            // carouselPrevCanvas.style.display = prevImageUrl ? 'block' : 'none';
            // setImageWithPlaceholder handles display
            carouselPrevImage.style.display = prevImageUrl ? 'block' : 'none'; // Control visibility of the img tag itself
            carouselPrevImagePlaceholder.style.display = prevImageUrl ? carouselPrevImagePlaceholder.style.display : 'none'; // Hide placeholder if no URL


            // Next Image in Carousel
            let nextImageUrl = null;
            if (carouselCurrentImageSetIndex < lightboxActivePanesForView.length - 1) {
                const nextPaneDataInSet = lightboxActivePanesForView[carouselCurrentImageSetIndex + 1];
                if (nextPaneDataInSet && nextPaneDataInSet.albumData.imageUrls.length > currentPairIndex && nextPaneDataInSet.albumData.imageUrls[currentPairIndex]) {
                    nextImageUrl = nextPaneDataInSet.albumData.imageUrls[currentPairIndex];
                }
            }
            setImageWithPlaceholder(
                carouselNextImage,
                carouselNextCanvas,
                carouselNextImagePlaceholder,
                null,
                nextImageUrl,
                true // isSideCarousel
            );
            // carouselNextCanvas.style.display = nextImageUrl ? 'block' : 'none';
            // setImageWithPlaceholder handles display
            carouselNextImage.style.display = nextImageUrl ? 'block' : 'none';
            carouselNextImagePlaceholder.style.display = nextImageUrl ? carouselNextImagePlaceholder.style.display : 'none';

            // Preload for carousel
            if (lightboxActivePanesForView.length > 0) {
                const currentPane = lightboxActivePanesForView[carouselCurrentImageSetIndex];
                if (currentPane && currentPane.albumData && currentPane.albumData.imageUrls) {
                    const urls = currentPane.albumData.imageUrls;
                    // Preload next/prev within the current album being viewed centrally in carousel
                    // This is different from preloading next/prev SETS.
                    // This logic might need refinement depending on desired preload behavior.
                    // For now, let's focus on preloading for the main view and next/prev sets.
                    // Preloading for carousel's own next/prev image *within the current set*
                    if (carouselCurrentImageSetIndex > 0) {
                        const prevPaneInSet = lightboxActivePanesForView[carouselCurrentImageSetIndex - 1];
                        if (prevPaneInSet.albumData.imageUrls[currentPairIndex]) preloadImage(prevPaneInSet.albumData.imageUrls[currentPairIndex]);
                    }
                    if (carouselCurrentImageSetIndex < lightboxActivePanesForView.length - 1) {
                        const nextPaneInSet = lightboxActivePanesForView[carouselCurrentImageSetIndex + 1];
                        if (nextPaneInSet.albumData.imageUrls[currentPairIndex]) preloadImage(nextPaneInSet.albumData.imageUrls[currentPairIndex]);
                    }
                }
            }

            updateLightboxControlsState();
        }

        function navigateCarousel(direction) {
            if (isSliderModeActive || lightboxActivePanesForView.length === 0) return;

            const newImageSetIndex = carouselCurrentImageSetIndex + direction;

            if (newImageSetIndex >= 0 && newImageSetIndex < lightboxActivePanesForView.length) {
                carouselCurrentImageSetIndex = newImageSetIndex;
                // The currentPairIndex remains the same.
                // We are just changing which pane's image (at that currentPairIndex) is in the center.
                updateCarouselDisplay(); // Update the carousel view with the new central image from the set
            }
        }

        function updateLightboxControlsState() {
            let navDisabled = true; // For the main carousel < > buttons
            let canGoPrevCarousel = false;
            let canGoNextCarousel = false;

            if (isSliderModeActive) {
                navDisabled = true; // Main < > buttons
            } else if (lightboxActivePanesForView.length > 0) { // Carousel mode
                navDisabled = lightboxActivePanesForView.length <= 1; // Disable if only one image in the set
                canGoPrevCarousel = carouselCurrentImageSetIndex > 0;
                canGoNextCarousel = carouselCurrentImageSetIndex < lightboxActivePanesForView.length - 1;
            } else { // Lightbox not properly initialized for carousel or no active panes for the current set
                 navDisabled = true;
            }

            const zoomDisabled = isSliderModeActive; // Zoom controls are for the central carousel image
            lightboxZoomInBtn.disabled = zoomDisabled;
            lightboxZoomOutBtn.disabled = zoomDisabled;
            lightboxZoomResetBtn.disabled = zoomDisabled;

            if (zoomDisabled) {
                lightboxZoomLevel.textContent = 'N/A';
            } else if (lightboxImage) { // Check if lightboxImage (central carousel) exists
                 lightboxZoomLevel.textContent = `${Math.round(lightboxCurrentScale * 100)}%`;
            }

            // Share button should be enabled if there's content in the lightbox (either mode)
            const shareDisabled = lightboxActivePanesForView.length === 0;
            lightboxShareBtn.disabled = shareDisabled;

            // Set Navigation Buttons (Shift + Arrows for changing currentPairIndex)
            const maxImageOverallIndex = getMaxImageIndex(); // Max value for currentPairIndex
            const setNavPossible = maxImageOverallIndex !== -1; // Is there at least one image index to navigate to?
            lightboxPrevSetBtn.disabled = !setNavPossible || currentPairIndex === 0;
            lightboxNextSetBtn.disabled = !setNavPossible || currentPairIndex === maxImageOverallIndex;
        }


        function setLightboxZoom(newScale) {
            if (isSliderModeActive) return;
            lightboxCurrentScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale));

            // Update transform on the hidden img (if drag logic uses its style.transform)
            let unscaledX = 0, unscaledY = 0;
            const currentTransform = lightboxImage.style.transform;
            const translateMatch = currentTransform.match(/translate\(([^p]+)px, ([^p]+)px\)/);
            if (translateMatch) {
                unscaledX = parseFloat(translateMatch[1]); // Keep current translation
                unscaledY = parseFloat(translateMatch[2]);
            }
            lightboxImage.style.transform = `translate(${unscaledX}px, ${unscaledY}px) scale(${lightboxCurrentScale})`;

            // Apply to canvas
            if (lightboxCanvas) {
                applyLightboxCanvasTransform(); // This will set canvas transform and cursor
            }
            lightboxZoomLevel.textContent = `${Math.round(lightboxCurrentScale * 100)}%`;
        }

        function resetLightboxZoomAndPosition() {
            if (isSliderModeActive) return;
            lightboxCurrentScale = 1;
            // Reset transform on the hidden img (if drag logic uses its style.transform)
            lightboxImage.style.transform = 'translate(0px, 0px) scale(1)';
            // Apply to canvas
            if (lightboxCanvas) {
                applyLightboxCanvasTransform(); // This will set canvas transform and cursor
            }
            lightboxZoomLevel.textContent = '100%';
        }

        lightboxCloseBtn.addEventListener('click', closeLightbox);

        if (carouselPrevCanvas) {
            carouselPrevCanvas.addEventListener('click', () => navigateCarousel(-1));
            // Add hover effects to canvas if needed (JS or CSS if :hover works on canvas)
            carouselPrevCanvas.addEventListener('mouseenter', () => { if (carouselPrevCanvas.style.opacity !== '0') carouselPrevCanvas.style.opacity = '1'; });
            carouselPrevCanvas.addEventListener('mouseleave', () => { if (carouselPrevCanvas.style.opacity !== '0') carouselPrevCanvas.style.opacity = '0.6'; });
        }
        if (carouselNextCanvas) {
            carouselNextCanvas.addEventListener('click', () => navigateCarousel(1));
            carouselNextCanvas.addEventListener('mouseenter', () => { if (carouselNextCanvas.style.opacity !== '0') carouselNextCanvas.style.opacity = '1'; });
            carouselNextCanvas.addEventListener('mouseleave', () => { if (carouselNextCanvas.style.opacity !== '0') carouselNextCanvas.style.opacity = '0.6'; });
        }

        lightboxZoomInBtn.addEventListener('click', () => setLightboxZoom(lightboxCurrentScale + ZOOM_STEP));
        lightboxZoomOutBtn.addEventListener('click', () => setLightboxZoom(lightboxCurrentScale - ZOOM_STEP));
        lightboxZoomResetBtn.addEventListener('click', resetLightboxZoomAndPosition);
        lightboxPrevSetBtn.addEventListener('click', () => navigateImageSet(-1)); // ADDED
        lightboxNextSetBtn.addEventListener('click', () => navigateImageSet(1));   // ADDED
        lightboxShareBtn.addEventListener('click', generateAndCopyShareLink);
        mainShareBtn.addEventListener('click', generateAndCopyMainShareLink); // ADDED

        lightboxOverlay.addEventListener('wheel', (e) => {
            if (isSliderModeActive) return;
            handleLightboxWheel(e)
        }, { passive: false });

        function handleLightboxWheel(e) {
            e.preventDefault();
            const zoomFactor = 0.5; 
            const direction = e.deltaY < 0 ? 1 : -1;
            const newScale = lightboxCurrentScale + (direction * ZOOM_STEP * zoomFactor);
            setLightboxZoom(newScale);
        }

        lightboxImage.addEventListener('mousedown', (e) => {
            if (isSliderModeActive || lightboxCurrentScale <= 1 || lightboxImage.style.opacity === '0') return; // Don't drag if invisible/loading
            lightboxIsDragging = true;
            lightboxImage.classList.add('grabbing');
            const computedStyle = window.getComputedStyle(lightboxImage);
            const transformMatrix = new DOMMatrix(computedStyle.transform);
            lightboxImgInitialX = transformMatrix.m41;
            lightboxImgInitialY = transformMatrix.m42;
            lightboxDragStartX = e.clientX;
            lightboxDragStartY = e.clientY;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isSliderModeActive) { handleSliderDragMove(e); return; }
            if (!lightboxIsDragging || lightboxCurrentScale <= 1) return;
            lastKnownMouseX = e.clientX;
            lastKnownMouseY = e.clientY;
            if (!animationFrameRequested) {
                requestAnimationFrame(updateImageTransformForDrag);
                animationFrameRequested = true;
            }
        });

        function updateImageTransformForDrag() {
            animationFrameRequested = false;
            if (!lightboxIsDragging) return;
            const dxScreen = lastKnownMouseX - lightboxDragStartX;
            const dyScreen = lastKnownMouseY - lightboxDragStartY;
            const newX = lightboxImgInitialX + dxScreen;
            const newY = lightboxImgInitialY + dyScreen;
            lightboxImage.style.transform = `translate(${newX}px, ${newY}px) scale(${lightboxCurrentScale})`;
            if (lightboxCanvas && !isSliderModeActive) { // ADDED: Apply to canvas
                applyLightboxCanvasTransform();
            }
        }


        document.addEventListener('mouseup', (e) => {
            if (isSliderModeActive) { handleSliderDragEnd(e); return; }
            if (lightboxIsDragging) {
                lightboxIsDragging = false;
                lightboxImage.classList.remove('grabbing');
            }
        });
        // For mouse leaving the window while dragging
        document.addEventListener('mouseleave', (e) => {
            if (isSliderModeActive) { if(activeSliderHandle) handleSliderDragEnd(e); return;}
            if (lightboxIsDragging) {
                lightboxIsDragging = false;
                lightboxImage.classList.remove('grabbing');
            }
        });
        
        function handleLightboxKeyPress(e) {
            if (!lightboxOverlay.classList.contains('active')) return;

            if (e.key === 'Escape') {
                closeLightbox();
                return;
            }

            // SHIFT + ARROW KEYS: Navigate within the current carousel set (intra-set)
            if (e.shiftKey) {
                if (isSliderModeActive) return; // Carousel (intra-set) navigation is not for slider mode

                if (e.key === 'ArrowLeft') { navigateCarousel(-1); return; }
                if (e.key === 'ArrowRight') { navigateCarousel(1); return; }
                // If other Shift combinations are needed, they'd go here.
                // Otherwise, if it was Shift + something else, let it fall through or be ignored.
            }

            // Handle 's' for toggling slider mode universally (if not a Shift+Arrow combo)
            if ((e.key === 's' || e.key === 'S') && !e.shiftKey) { // Ensure it's not Shift+S if that could be a conflict
                toggleSliderComparisonMode();
                return; // Consume 's' keypress
            }

            // If in slider mode, and it wasn't 's' or 'Escape' or a Shift+Arrow for carousel:
            // We only want ArrowLeft/ArrowRight (for set navigation) to proceed.
            // Other keys like zoom (+, -, 0) should be blocked for slider.
            if (isSliderModeActive) {
                if (e.key === 'ArrowLeft') {
                    navigateImageSet(-1); // Navigate between comparison sets
                } else if (e.key === 'ArrowRight') {
                    navigateImageSet(1);  // Navigate between comparison sets
                }
                // Any other key in slider mode (not 's', 'Escape', or Arrows for set nav) is ignored.
                return;
            }

            // --- If NOT in slider mode (i.e., Carousel Mode) AND not a consumed Shift+Arrow or 's' ---
            // Arrow keys (NO SHIFT) for Image Set navigation
            // Other keys for zoom, etc.
            switch (e.key) {
                case 'ArrowLeft': // NO SHIFT: Navigate between comparison sets (changes currentPairIndex)
                    navigateImageSet(-1);
                    break;
                case 'ArrowRight': // NO SHIFT: Navigate between comparison sets (changes currentPairIndex)
                    navigateImageSet(1);
                    break;
                case '+':
                case '=':
                    setLightboxZoom(lightboxCurrentScale + ZOOM_STEP);
                    break;
                case '-':
                    setLightboxZoom(lightboxCurrentScale - ZOOM_STEP);
                    break;
                case '0':
                    resetLightboxZoomAndPosition();
                    break;
                // 's' is handled above now
            }
        }

        function generateAndCopyShareLink() {
            if (lightboxActivePanesForView.length === 0) {
                alert("No active images to share.");
                lightboxShareBtn.innerHTML = '🔗'; // Reset button if it was "Copied!"
                updateLightboxControlsState(); // Re-evaluate disabled state
                return;
            }

            // albumIdsInComparison should be the IDs of albums currently in the lightbox view (slider or carousel)
            const albumIdsInComparison = lightboxActivePanesForView.map(pane => pane.albumData._id);

            if (albumIdsInComparison.length === 0) { // Should be caught by the first check
                alert("Cannot determine albums to share for the current view.");
                 lightboxShareBtn.innerHTML = '🔗';
                updateLightboxControlsState();
                return;
            }
            
            const shareIndex = currentPairIndex; // Global currentPairIndex
            let primaryAlbumIdForShare = null;

            if (isSliderModeActive) {
                // For slider mode, lightboxActivePanesForView holds the slider images.
                // The "primary" can be considered the first album in the slider set.
                if (lightboxActivePanesForView.length > 0 && lightboxActivePanesForView[0].albumData) {
                    primaryAlbumIdForShare = lightboxActivePanesForView[0].albumData._id;
                }
            } else { // Carousel Mode
                // lightboxActivePanesForView holds the images in the current comparison set.
                // carouselCurrentImageSetIndex points to the one in the center.
                if (carouselCurrentImageSetIndex < lightboxActivePanesForView.length &&
                    lightboxActivePanesForView[carouselCurrentImageSetIndex] &&
                    lightboxActivePanesForView[carouselCurrentImageSetIndex].albumData) {
                    primaryAlbumIdForShare = lightboxActivePanesForView[carouselCurrentImageSetIndex].albumData._id;
                }
            }

            // Fallback if primaryAlbumIdForShare couldn't be determined but we have a set
            if (!primaryAlbumIdForShare && albumIdsInComparison.length > 0) {
                primaryAlbumIdForShare = albumIdsInComparison[0];
                console.warn("Fallback: Primary album ID for share link set to first in current lightbox set.");
            }
            
            if (!primaryAlbumIdForShare) { // Final check
                alert("Could not determine primary album for sharing.");
                 lightboxShareBtn.innerHTML = '🔗';
                updateLightboxControlsState();
                return;
            }

            const params = new URLSearchParams();
            params.set('shareAlbums', albumIdsInComparison.join(',')); // Albums in the current lightbox set
            params.set('shareIndex', shareIndex.toString());          // The currentPairIndex
            params.set('viewContext', 'lightbox');
            params.set('primaryAlbumId', primaryAlbumIdForShare);     // Album that was central or first

            if (isSliderModeActive) {
                params.set('sliderMode', 'true');
            }

            const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;

            navigator.clipboard.writeText(shareUrl).then(() => {
                const originalText = lightboxShareBtn.innerHTML;
                lightboxShareBtn.innerHTML = 'Copied!';
                lightboxShareBtn.disabled = true;
                setTimeout(() => {
                    lightboxShareBtn.innerHTML = '🔗'; 
                    updateLightboxControlsState(); // Re-evaluates disabled state, including share button
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy share link: ', err);
                prompt("Failed to copy. Please copy this link manually:", shareUrl);
                lightboxShareBtn.innerHTML = '🔗'; // Reset on error
                updateLightboxControlsState();
            });
        }

        // --- LIGHTBOX SLIDER COMPARISON ---
        lightboxSliderToggleBtn.addEventListener('click', toggleSliderComparisonMode);

        function updateSliderToggleButton() {
            const numComparable = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]).length;
            lightboxSliderToggleBtn.disabled = numComparable < 2;
            lightboxSliderToggleBtn.innerHTML = isSliderModeActive ? 'Exit Sliders' : '🎚️';
        }

        function toggleSliderComparisonMode() {
            const sliderImagePanes = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]);
            sliderNumImages = sliderImagePanes.length;

            if (sliderNumImages < 2 && !isSliderModeActive) { // Trying to activate slider without enough images
                console.warn("Slider mode requires at least 2 images.");
                lightboxSliderToggleBtn.innerHTML = '🎚️';
                isSliderModeActive = false; // Explicitly ensure it's false
                localStorage.setItem('lightboxViewMode', 'single'); // Save fallback
                updateLightboxControlsState(); // Update button states
                return;
            }

            const wasSliderMode = isSliderModeActive; // Capture state before toggle

            if (!wasSliderMode) { // Entering slider mode
                lastCarouselIndexBeforeSlider = carouselCurrentImageSetIndex; // Store current carousel index
            }

            isSliderModeActive = !isSliderModeActive;
            localStorage.setItem('lightboxViewMode', isSliderModeActive ? 'slider' : 'single');

            if (wasSliderMode && !isSliderModeActive) { // <<< Transitioning FROM slider TO carousel
                // Restore the carousel index
                carouselCurrentImageSetIndex = lastCarouselIndexBeforeSlider;

                // Validate the restored index against the current lightboxActivePanesForView
                if (lightboxActivePanesForView.length > 0) {
                    if (carouselCurrentImageSetIndex >= lightboxActivePanesForView.length) {
                        carouselCurrentImageSetIndex = Math.max(0, lightboxActivePanesForView.length - 1);
                    }
                } else {
                    // If no active panes, default to 0, though updateLightboxView might close if empty.
                    carouselCurrentImageSetIndex = 0;
                }
            }
            updateLightboxView();
        }
        
        async function setupSliderComparison() {
            if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'block';
            if (lightboxCarousel) lightboxCarousel.style.display = 'none';
            [lightboxImagePlaceholder, carouselPrevImagePlaceholder, carouselNextImagePlaceholder].forEach(p => {
                if (p) p.style.display = 'none';
            });
            [lightboxImage, carouselPrevImage, carouselNextImage].forEach(img => {
                if (img) { img.style.opacity = '0'; img.style.display = 'none';} // Also hide display
            });
            [lightboxCanvas, carouselPrevCanvas, carouselNextCanvas].forEach(cvs => { // Hide carousel canvases
                if (cvs) { cvs.style.opacity = '0'; cvs.style.display = 'none';}
            });


            const sliderImagePanesData = lightboxActivePanesForView.filter(p => p.urls && p.urls[currentPairIndex]);
            sliderNumImages = sliderImagePanesData.length;

            const sliderElementsToReset = [
                { canvas: sliderCanvas1, placeholder: sliderImg1Placeholder },
                { canvas: sliderCanvas2, placeholder: sliderImg2Placeholder },
                { canvas: sliderCanvas3, placeholder: sliderImg3Placeholder }
            ];
            sliderElementsToReset.forEach(item => {
                if (item.canvas) {
                    const ctx = item.canvas.getContext('2d');
                    ctx.clearRect(0, 0, item.canvas.width, item.canvas.height);
                    item.canvas.style.display = 'none';
                    item.canvas.style.opacity = '0';
                }
                if (item.placeholder) {
                    item.placeholder.style.display = 'block';
                    item.placeholder.style.backgroundColor = 'var(--bg-tertiary-color)';
                    item.placeholder.textContent = 'Loading...';
                    item.placeholder.style.width = '100%';
                    item.placeholder.style.height = '100%';
                }
            });

            if (sliderNumImages < 2) {
                console.warn("Cannot setup slider comparison with less than 2 images.");
                if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';
                toggleSliderComparisonMode();
                return;
            }
            lightboxSliderView.style.display = 'flex';

            const firstImagePane = sliderImagePanesData[0];
            if (!firstImagePane || !firstImagePane.urls || !firstImagePane.urls[currentPairIndex]) {
                console.error("First image for slider dimension calculation is missing.");
                if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';
                toggleSliderComparisonMode();
                return;
            }
            const firstImageURL = firstImagePane.urls[currentPairIndex];

            const tempImg = new Image();

            tempImg.onload = () => {
                const containerWidth = lightboxImageContainer.clientWidth;
                const containerHeight = lightboxImageContainer.clientHeight;

                if (containerWidth === 0 || containerHeight === 0) {
                    console.warn("Lightbox image container has no dimensions for slider setup.");
                    if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';
                    toggleSliderComparisonMode();
                    return;
                }

                const imgAspectRatio = tempImg.naturalWidth / tempImg.naturalHeight;
                const containerAspectRatio = containerWidth / containerHeight;

                if (imgAspectRatio > containerAspectRatio) {
                    sliderRenderedWidth = containerWidth;
                    sliderRenderedHeight = containerWidth / imgAspectRatio;
                } else {
                    sliderRenderedHeight = containerHeight;
                    sliderRenderedWidth = containerHeight * imgAspectRatio;
                }

                lightboxSliderContent.style.width = `${sliderRenderedWidth}px`;
                lightboxSliderContent.style.height = `${sliderRenderedHeight}px`;
                sliderOrientation = (sliderRenderedWidth > sliderRenderedHeight) ? 'vertical' : 'horizontal';

                const imagesToLoadPromises = [];
                const sliderElements = [
                    { img: sliderImg1, canvas: sliderCanvas1, placeholder: sliderImg1Placeholder, url: null },
                    { img: sliderImg2, canvas: sliderCanvas2, placeholder: sliderImg2Placeholder, url: null },
                    { img: sliderImg3, canvas: sliderCanvas3, placeholder: sliderImg3Placeholder, url: null }
                ];

                // --- CORRECTED URL ASSIGNMENT ---
                if (sliderImagePanesData[0] && sliderImagePanesData[0].urls[currentPairIndex]) {
                    sliderElements[0].url = sliderImagePanesData[0].urls[currentPairIndex];
                }
                if (sliderImagePanesData[1] && sliderImagePanesData[1].urls[currentPairIndex]) {
                    sliderElements[1].url = sliderImagePanesData[1].urls[currentPairIndex];
                }
                // This was the problematic part for the 3rd image:
                if (sliderNumImages === 3) {
                    if (sliderImagePanesData[2] && sliderImagePanesData[2].urls[currentPairIndex]) {
                        sliderElements[2].url = sliderImagePanesData[2].urls[currentPairIndex];
                    } else {
                        sliderElements[2].url = null; // Explicitly null if data is missing for 3rd image but expected
                    }
                } else { // sliderNumImages is 2 (since <2 is handled earlier)
                    sliderElements[2].url = null; // No 3rd image, so URL is null
                }
                // --- END OF CORRECTION ---


                sliderElements.forEach((item, index) => {
                    // We will call setImageWithPlaceholder for all 3 slots.
                    // If item.url is null, setImageWithPlaceholder will handle showing "No image" or clearing.
                    if (item.img && item.canvas && item.placeholder) {
                        setImageWithPlaceholder(item.img, item.canvas, item.placeholder, null, item.url, false, true);
                        
                        if (item.url) { // Only add to promises if there's a URL to load
                            imagesToLoadPromises.push(new Promise(resolve => {
                                if (imagePreloadManager.cache[item.url] && imagePreloadManager.cache[item.url].complete && imagePreloadManager.cache[item.url].naturalWidth > 0) {
                                    resolve();
                                    return;
                                }
                                const imgToWatch = item.img;
                                const originalOnload = imgToWatch.onload;
                                const originalOnerror = imgToWatch.onerror;
                                imgToWatch.onload = (e) => { if(originalOnload) originalOnload(e); resolve(); };
                                imgToWatch.onerror = (e) => { if(originalOnerror) originalOnerror(e); resolve(); }; // Resolve even on error to not block Promise.all
                            }));
                        }
                    }
                });

                Promise.all(imagesToLoadPromises).then(() => {
                    initializeSliderHandles();
                    updateSliderClipping();
                    if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';
                }).catch(err => {
                    console.error("Error in Promise.all for slider image loading:", err);
                    if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';
                });
                    
                lightboxCaption.textContent = '';
                lightboxCaption.appendChild(document.createTextNode('Comparing: '));
                sliderImagePanesData.forEach((pane, idx) => {
                    if (idx < sliderNumImages) { // Only display titles for active slider images
                        const titleSpan = document.createElement('span');
                        titleSpan.textContent = pane.albumData.title;
                        titleSpan.classList.add('image-title');
                        lightboxCaption.appendChild(titleSpan);
                        if (idx < sliderNumImages - 1) {
                            lightboxCaption.appendChild(document.createTextNode(' vs '));
                        }
                    }
                });
            };

            tempImg.onerror = () => {
                console.error("Failed to load first image for slider dimensions. Cannot setup slider.");
                if (lightboxImageSpinner) lightboxImageSpinner.style.display = 'none';
                isSliderModeActive = false;
                localStorage.setItem('lightboxViewMode', 'single');
                updateLightboxView();
                showFancyNotice("Error: Could not prepare slider view.", "error", false, 3000);
            };
            tempImg.src = firstImageURL;
        }

        function initializeSliderHandles() {
            sliderHandle1.style.display = 'block';
            sliderHandle1.className = `slider-handle ${sliderOrientation}`;
            
            if (sliderNumImages === 2) {
                slider1Percent = 50;
                sliderHandle2.style.display = 'none';
            } else if (sliderNumImages === 3) {
                slider1Percent = 33.33;
                slider2Percent = 66.67;
                sliderHandle2.style.display = 'block';
                sliderHandle2.className = `slider-handle ${sliderOrientation}`;
            }
            positionSliderHandles();
        }

        function positionSliderHandles() {
            if (sliderOrientation === 'vertical') { // Sliders are vertical lines, move L/R
                const pos1 = sliderRenderedWidth * (slider1Percent / 100);
                sliderHandle1.style.left = `${pos1}px`;
                sliderHandle1.style.top = '0px';
                if (sliderNumImages === 3) {
                    const pos2 = sliderRenderedWidth * (slider2Percent / 100);
                    sliderHandle2.style.left = `${pos2}px`;
                    sliderHandle2.style.top = '0px';
                }
            } else { // Sliders are horizontal lines, move U/D
                const pos1 = sliderRenderedHeight * (slider1Percent / 100);
                sliderHandle1.style.top = `${pos1}px`;
                sliderHandle1.style.left = '0px';
                if (sliderNumImages === 3) {
                    const pos2 = sliderRenderedHeight * (slider2Percent / 100);
                    sliderHandle2.style.top = `${pos2}px`;
                    sliderHandle2.style.left = '0px';
                }
            }
        }

        function updateSliderClipping() {
            const s1p = (sliderOrientation === 'vertical' ? sliderRenderedWidth : sliderRenderedHeight) * (slider1Percent / 100);
            let s2p;
            if (sliderNumImages === 3) {
                s2p = (sliderOrientation === 'vertical' ? sliderRenderedWidth : sliderRenderedHeight) * (slider2Percent / 100);
            }

            // Target canvas elements for clipping
            const canvasTarget1 = sliderCanvas1;
            const canvasTarget2 = sliderCanvas2;
            const canvasTarget3 = sliderNumImages === 3 ? sliderCanvas3 : null;

            if (sliderOrientation === 'vertical') {
                if (canvasTarget1) canvasTarget1.style.clipPath = `polygon(0 0, ${s1p}px 0, ${s1p}px 100%, 0 100%)`;
                if (sliderNumImages === 2) {
                    if (canvasTarget2) canvasTarget2.style.clipPath = `polygon(${s1p}px 0, 100% 0, 100% 100%, ${s1p}px 100%)`;
                } else if (sliderNumImages === 3) {
                    if (canvasTarget2) canvasTarget2.style.clipPath = `polygon(${s1p}px 0, ${s2p}px 0, ${s2p}px 100%, ${s1p}px 100%)`;
                    if (canvasTarget3) canvasTarget3.style.clipPath = `polygon(${s2p}px 0, 100% 0, 100% 100%, ${s2p}px 100%)`;
                }
            } else { // Horizontal sliders
                if (canvasTarget1) canvasTarget1.style.clipPath = `polygon(0 0, 100% 0, 100% ${s1p}px, 0 ${s1p}px)`;
                if (sliderNumImages === 2) {
                    if (canvasTarget2) canvasTarget2.style.clipPath = `polygon(0 ${s1p}px, 100% ${s1p}px, 100% 100%, 0 100%)`;
                } else if (sliderNumImages === 3) {
                    if (canvasTarget2) canvasTarget2.style.clipPath = `polygon(0 ${s1p}px, 100% ${s1p}px, 100% ${s2p}px, 0 ${s2p}px)`;
                    if (canvasTarget3) canvasTarget3.style.clipPath = `polygon(0 ${s2p}px, 100% ${s2p}px, 100% 100%, 0 100%)`;
                }
            }
        }
        
        [sliderHandle1, sliderHandle2].forEach(handle => {
            handle.addEventListener('mousedown', handleSliderDragStart);
            handle.addEventListener('touchstart', handleSliderDragStart, { passive: false });
        });

        function handleSliderDragStart(e) {
            if (!isSliderModeActive) return;
            e.preventDefault(); // Prevent text selection, etc.
            activeSliderHandle = e.currentTarget;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);

            if (sliderOrientation === 'vertical') {
                sliderDragStartPos = clientX - activeSliderHandle.getBoundingClientRect().left;
            } else {
                sliderDragStartPos = clientY - activeSliderHandle.getBoundingClientRect().top;
            }
            // Global listeners for mousemove/mouseup are already set up
            // For touch, we add them here
            document.addEventListener('touchmove', handleSliderDragMove, { passive: false });
            document.addEventListener('touchend', handleSliderDragEnd);
        }

        function handleSliderDragMove(e) {
            if (!isSliderModeActive || !activeSliderHandle) return;
            e.preventDefault();

            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const rect = lightboxSliderContent.getBoundingClientRect();
            let newPercent;

            if (sliderOrientation === 'vertical') {
                let newX = clientX - rect.left - (activeSliderHandle === sliderHandle1 ? sliderHandle1.offsetWidth / 2 : sliderHandle2.offsetWidth / 2);
                newX = Math.max(0, Math.min(newX, sliderRenderedWidth));
                newPercent = (newX / sliderRenderedWidth) * 100;

                if (activeSliderHandle === sliderHandle1) {
                    if (sliderNumImages === 3) newPercent = Math.min(newPercent, slider2Percent - 1); // Ensure min 1% gap
                    slider1Percent = Math.max(0, Math.min(100, newPercent));
                } else { // sliderHandle2
                    newPercent = Math.max(newPercent, slider1Percent + 1); // Ensure min 1% gap
                    slider2Percent = Math.max(0, Math.min(100, newPercent));
                }
            } else { // horizontal
                let newY = clientY - rect.top - (activeSliderHandle === sliderHandle1 ? sliderHandle1.offsetHeight / 2 : sliderHandle2.offsetHeight / 2);
                newY = Math.max(0, Math.min(newY, sliderRenderedHeight));
                newPercent = (newY / sliderRenderedHeight) * 100;

                if (activeSliderHandle === sliderHandle1) {
                    if (sliderNumImages === 3) newPercent = Math.min(newPercent, slider2Percent - 1);
                    slider1Percent = Math.max(0, Math.min(100, newPercent));
                } else { // sliderHandle2
                    newPercent = Math.max(newPercent, slider1Percent + 1);
                    slider2Percent = Math.max(0, Math.min(100, newPercent));
                }
            }
            positionSliderHandles();
            updateSliderClipping();
        }

        function handleSliderDragEnd(e) {
            if (!isSliderModeActive || !activeSliderHandle) return;
            activeSliderHandle = null;
            document.removeEventListener('touchmove', handleSliderDragMove);
            document.removeEventListener('touchend', handleSliderDragEnd);
        }

        // --- PAGE LOAD ---
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);

            const urlParams = new URLSearchParams(window.location.search);
            const albumsParam = urlParams.get('shareAlbums');
            const indexParam = urlParams.get('shareIndex');
            const sliderModeParam = urlParams.get('sliderMode'); // ADDED
            const viewContextParam = urlParams.get('viewContext'); // ADDED
            const primaryAlbumIdParam = urlParams.get('primaryAlbumId'); // ADDED

            if (albumsParam && indexParam) {
                sharedAlbumIdsToLoad = albumsParam.split(',').filter(id => id.trim() !== '');
                sharedIndexToLoad = parseInt(indexParam, 10);
                sharedInitialSliderMode = sliderModeParam === 'true'; // ADDED: Store boolean
                sharedViewContext = viewContextParam || 'main';      // ADDED: Default to 'main' if not present
                sharedPrimaryAlbumId = primaryAlbumIdParam; // ADDED
                
                if (sharedAlbumIdsToLoad.length > 0 && !isNaN(sharedIndexToLoad) && sharedPrimaryAlbumId) {
                    isProcessingSharedLink = true;

                    const newUrl = window.location.origin + window.location.pathname;
                    history.replaceState(null, '', newUrl);
                    
                    showFancyNotice('Attempting to load shared comparison...', 'info', true);
                } else {
                    sharedAlbumIdsToLoad = null;
                    sharedIndexToLoad = null;
                    sharedInitialSliderMode = false; // Reset if params are invalid
                    sharedViewContext = 'main';      // Reset
                    sharedPrimaryAlbumId = null; // Reset
                }
            }

            checkAndPromptForApiAccess();
        });
    </script>
</body>
</html>